local gooey = require "gooey.gooey"
local dirtylarry = require "gooey-dirtylarry.dirtylarry"

local string_start = "{\"NORMALSection\":[{\"name\":\"Empty\",\"distance\":\"-12\",\"properties\":[{\"startUnit\":\"-12\"}]}],\"Volume\":["
local string_end = "],\"Decor\":[],\"DecorGroups\":[]}"
local vol_1 = "{\"type\":\""
local vol_1b= "\",\"offset\":\"("
local vol_2 = ")\",\"scale\":\"("
local vol_3 = ")\",\"worldPosition\":\"("
local vol_4 = ")\",\"localScale\":\"("
local vol_5 = ")\",\"groupIndex\":\""
local vol_6 = "\",\"processingOrder\":\""
local vol_7 = "\"}"

local walkway = "{\"type\":\"Subtractive\",\"offset\":\"(-1, -1, -4)\",\"scale\":\"(2, 1, 250)\",\"worldPosition\":\"(0.00, -0.25, 60.50)\",\"localScale\":\"(1.00, 0.50, 125.00)\",\"groupIndex\":\"1\",\"processingOrder\":\"1000\"},"

local comma = ", "
local volume_type = {[true] = "Additive", [false] = "Subtractive"}

local image_data = {}
local MAX_Z = 3600

local filter = 0
local filter_threshold = 128
local invert = false
local create_additive = true
local create_subtractive = false
local delete_walkway = false
local walkway_seconds = 60

local MIN_X, MAX_X, MIN_Y, MAX_Y = -84, 82, -80, 85
local min_x, max_x, min_y, max_y = MIN_X, MAX_X, MIN_Y, MAX_Y

local offset_x, offset_y = 0, 0
local path_centre = vmath.vector3(321.5, 251.5, 0)

local z_depth = 1
local processing_order = "1500"

local starting_group_index = 1
local separate_group_index = true

local volumes = {}

local preview_node, message_box, crop_stencil, range_box
local current_preview = 0


local function is_geo(pixels, width, x, y)
	local index = y * width * 4 + x * 4 + 1
	local value = pixels[index + filter]
	if invert then
		return value < filter_threshold
	end
	return value > filter_threshold
end

local function get_volume(pos_x, pos_y, pos_z, scale_x, scale_y, scale_z, group_index, is_additive)
	local vol = vol_1..volume_type[is_additive]..vol_1b..tostring(pos_x)..comma..tostring(pos_y)..comma..tostring(pos_z)..vol_2..tostring(scale_x)..comma..tostring(scale_y)..comma..tostring(scale_z)
	vol = vol..vol_3..tostring(((scale_x * 0.5) + pos_x) * 0.5)..comma..tostring(((scale_y * 0.5) + pos_y) * 0.5)..comma..tostring(((scale_z * 0.5) + pos_z) * 0.5)
	vol = vol..vol_4..tostring(scale_x * 0.5)..comma..tostring(scale_y * 0.5)..comma..tostring(scale_z * 0.5)..vol_5..group_index..vol_6..processing_order..vol_7
	return vol
end

local function add_warning(err)

end

local function set_preview_image(image)
	current_preview = image or current_preview
	gui.set_texture(preview_node, tostring(image_data[current_preview].z))
	gui.set_text(gui.get_node("preview_label"), "Z position: "..tostring(image_data[current_preview].z))
end

local function load_images()
	for key, val in ipairs(image_data) do
		gui.delete_texture(tostring(val.z))
	end
	image_data = {}
	for z = -16, MAX_Z do
		local filename = "input/"..tostring(z)..".png"
		local f = io.open(filename, "rb")
		if f then
			local image = f:read("*a")
			local buf, w, h = png.decode_rgba(image, true)
			if not (w == 167 and h == 166) then
				add_warning(hash("wrong_size_image"))
			else
				local pixels = buffer.get_stream(buf, hash("pixels"))
				gui.new_texture(tostring(z), w, h, "rgba", buffer.get_bytes(buf, hash("pixels")), true)
				table.insert(image_data, {pixels = pixels, w = w, h = h, z = z})
			end
			io.close(f)
		end
	end
	if #image_data < 1 then
		gui.set_text(message_box, "No files found in the input directory.")
	else
		gui.set_text(message_box, tostring(#image_data).." images loaded.")
		set_preview_image(1)
	end
end

local function divide_picture(index, group_index)
	local pixel_values = {}
	local width = max_x - min_x + 1
	local height = max_y - min_y + 1
	local volume_created = false
	for i = 1, width * height do
		local x = (i - 1) % width + (min_x - MIN_X)
		local y = math.floor((i - 1) / width) + (min_y - MIN_Y)
		table.insert(pixel_values, is_geo(image_data[index].pixels, image_data[index].w, x, y))
	end
	for starting_pixel = 1, width * height do
		if not (pixel_values[starting_pixel] == nil) then
			local volume_width = 1
			local volume_height = 0
			local is_additive = pixel_values[starting_pixel]
			pixel_values[starting_pixel] = nil
			repeat
				if (starting_pixel + volume_width - 1) % width == 0 then
					break
				end
				if pixel_values[starting_pixel + volume_width] == is_additive then
					pixel_values[starting_pixel + volume_width] = nil
					volume_width = volume_width + 1
				else
					break
				end
			until false
			local height_found
			repeat
				volume_height = volume_height + 1
				for i = 1, volume_width do
					if not (pixel_values[starting_pixel + width * volume_height + i - 1] == is_additive) then
						height_found = true
						break
					end
				end
				if not height_found then
					for i = 1, volume_width do
						pixel_values[starting_pixel + width * volume_height + i - 1] = nil
					end
				end
			until height_found
			if (is_additive and create_additive) or (create_subtractive and not is_additive) then
				local x = min_x + offset_x + (starting_pixel - 1) % width
				local y = min_y + offset_y + math.floor(starting_pixel / width)
				table.insert(volumes, get_volume(x, y, image_data[index].z, volume_width, volume_height, z_depth, group_index, is_additive))
				volume_created = true
			end
		end
	end
	return volume_created
end

local function update_radio(radio)
	if radio.released_now then
		if radio.selected then
			gui.play_flipbook(radio.node, hash("radio_selected"))
		else
			gui.play_flipbook(radio.node, hash("radio_normal"))
		end
	elseif not radio.pressed and radio.over_now then
		gui.play_flipbook(radio.node, hash("radio_over"))
	elseif not radio.pressed and radio.out_now then
		gui.play_flipbook(radio.node, hash("radio_normal"))
	end
end

function init(self)
	msg.post(".", hash("acquire_input_focus"))
	gooey.checkbox("additive/box").set_checked(true)
	gooey.checkbox("show_path/box").set_checked(true)
	gooey.checkbox("image_group/box").set_checked(true)
	gooey.input("group_index/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(starting_group_index))
	gooey.input("depth/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(z_depth))
	gooey.input("min_x/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(MIN_X))
	gooey.input("max_x/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(MAX_X))
	gooey.input("min_y/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(MIN_Y))
	gooey.input("max_y/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(MAX_Y))
	gooey.input("offset_x/text", gui.KEYBOARD_TYPE_DEFAULT).set_text("0")
	gooey.input("offset_y/text", gui.KEYBOARD_TYPE_DEFAULT).set_text("0")
	gooey.input("processing_order/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(processing_order)
	update_radio(gooey.radio("filter_white/button").set_selected(true))
	update_radio(gooey.radio("filter_alpha/button").set_selected(false))
	preview_node = gui.get_node("preview")
	message_box = gui.get_node("message_box")
	crop_stencil = gui.get_node("crop_stencil")
	range_box = gui.get_node("range_box")
end

local function update_button(button)
	if button.pressed_now then
		gui.play_flipbook(button.node, hash("button_pressed"))
	elseif button.released_now then
		gui.play_flipbook(button.node, hash("button_normal"))
	elseif not button.pressed and button.over_now then
		gui.play_flipbook(button.node, hash("button_over"))
	elseif not button.pressed and button.out_now then
		gui.play_flipbook(button.node, hash("button_normal"))
	end
end

local function set_stencil_size()
	local w = (max_x - min_x + 1) * 3
	local h = (max_y - min_y + 1) * 3
	local x = -250.5 + (min_x + math.abs(MIN_X)) * 3
	local y = -249 + (min_y + math.abs(MIN_Y)) * 3
	gui.set_size(crop_stencil, vmath.vector3(w, h, 1))
	gui.set_position(crop_stencil, vmath.vector3(x, y, 0))
	gui.set_position(range_box, vmath.vector3(min_x * -3 -252, min_y * -3 - 239.5, 0))
end

local function node_text_to_number(node)
	return tonumber(gui.get_text(gui.get_node(node)))
end

local function refresh_input(input, config, node_id)
	local cursor = gui.get_node(node_id .. "/cursor")
	if input.selected then
		gui.set_enabled(cursor, true)
		gui.set_position(cursor, vmath.vector3(14 + input.total_width, 0, 0))
		gui.cancel_animation(cursor, gui.PROP_COLOR)
		gui.set_color(cursor, vmath.vector4(1))
		gui.animate(cursor, gui.PROP_COLOR, vmath.vector4(1,1,1,0), gui.EASING_INSINE, 0.8, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
	else
		gui.set_enabled(cursor, false)
		gui.cancel_animation(cursor, gui.PROP_COLOR)
	end
end
function dirtylarry_input(node_id, keyboard_type, action_id, action, config)
	return gooey.input(node_id .. "/text", keyboard_type, action_id, action, config, function(input)
		refresh_input(input, config, node_id)
	end)
end

local function update_input(input)
	local value
	if input.node_id == hash("depth/text") then
		value = tonumber(input.text)
		if not value or value < 1 then
			value = 1
		end
		z_depth = value
		gooey.input("depth/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(value))
	elseif input.node_id == hash("min_x/text") then
		value = tonumber(input.text) or 0
		local max_value = node_text_to_number("max_x/text")
		if value > max_value then
			value = max_value
		elseif value < MIN_X then
			value = MIN_X
		end
		min_x = value
		gooey.input("min_x/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(value))
		set_stencil_size()
	elseif input.node_id == hash("min_y/text") then
		value = tonumber(input.text) or 0
		local max_value = node_text_to_number("max_y/text")
		if value > max_value then
			value = max_value
		elseif value < MIN_Y then
			value = MIN_Y
		end
		min_y = value
		gooey.input("min_y/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(value))
		set_stencil_size()
	elseif input.node_id == hash("max_x/text") then
		value = tonumber(input.text) or 0
		local min_value = node_text_to_number("min_x/text")
		if value > MAX_X then
			value = MAX_X
		elseif value < min_value then
			value = min_value
		end
		max_x = value
		gooey.input("max_x/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(value))
		set_stencil_size()
	elseif input.node_id == hash("max_y/text") then
		value = tonumber(input.text) or 0
		local min_value = node_text_to_number("min_y/text")
		if value > MAX_Y then
			value = MAX_Y
		elseif value < min_value then
			value = min_value
		end
		max_y = value
		gooey.input("max_y/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(value))
		set_stencil_size()
	elseif input.node_id == hash("processing_order/text") then
		value = tonumber(input.text) or 0
		gooey.input("processing_order/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(value))
		processing_order = value
	elseif input.node_id == hash("offset_x/text") then
		value = tonumber(input.text) or 0
		if value > 82 then
			value = 82
		elseif value < -82 then
			value = -82
		end
		gooey.input("offset_x/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(value))
		offset_x = value
		gui.set_position(gui.get_node("player_path"), vmath.vector3(path_centre.x - (offset_x * 3), path_centre.y - (offset_y * 3), 0))
	elseif input.node_id == hash("offset_y/text") then
		value = tonumber(input.text) or 0
		if value > 82 then
			value = 82
		elseif value < -82 then
			value = -82
		end
		gooey.input("offset_y/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(value))
		offset_y = value
		gui.set_position(gui.get_node("player_path"), vmath.vector3(path_centre.x - (offset_x * 3), path_centre.y - (offset_y * 3), 0))
	elseif input.node_id == hash("group_index/text") then
		value = tonumber(input.text) or 0
		if value < 1 then
			value = 1
		end
		gooey.input("group_index/text", gui.KEYBOARD_TYPE_DEFAULT).set_text(tostring(value))
		starting_group_index = value
	end
end

local function refresh_input(input, config, node_id)
	local cursor = gui.get_node(node_id .. "/cursor")
	if input.selected then
		gui.set_enabled(cursor, true)
		gui.set_position(cursor, vmath.vector3(14 + input.total_width, 0, 0))
		gui.cancel_animation(cursor, gui.PROP_COLOR)
		gui.set_color(cursor, vmath.vector4(1))
		gui.animate(cursor, gui.PROP_COLOR, vmath.vector4(1,1,1,0), gui.EASING_INSINE, 0.8, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
	else
		gui.set_enabled(cursor, false)
		gui.cancel_animation(cursor, gui.PROP_COLOR)
	end
end
local function dirtylarry_input(node_id, keyboard_type, action_id, action, config)
	return gooey.input(node_id .. "/text", keyboard_type, action_id, action, config, function(input)
		refresh_input(input, config, node_id)
		if input.deselected_now then
			update_input(input)
		end
	end)
end

local function on_checked(checkbox)
	if checkbox.node_id == hash("additive/box") then
		create_additive = checkbox.checked
	elseif checkbox.node_id == hash("subtractive/box") then
		create_subtractive = checkbox.checked
	elseif checkbox.node_id == hash("invert/box") then
		invert = checkbox.checked
		msg.post("@render:", hash("invert_preview"), {invert = invert})
	elseif checkbox.node_id == hash("show_path/box") then
		gui.set_visible(gui.get_node("player_path"), checkbox.checked)
	elseif checkbox.node_id == hash("image_group/box") then
		separate_group_index = checkbox.checked
	end
end

local text_field_button_data = {}
text_field_button_data[hash("min_x_down/bg")] = {change = -1, node_id = "min_x/text"}
text_field_button_data[hash("min_x_up/bg")] = {change = 1, node_id = "min_x/text"}
text_field_button_data[hash("max_x_down/bg")] = {change = -1, node_id = "max_x/text"}
text_field_button_data[hash("max_x_up/bg")] = {change = 1, node_id = "max_x/text"}
text_field_button_data[hash("min_y_down/bg")] = {change = -1, node_id = "min_y/text"}
text_field_button_data[hash("min_y_up/bg")] = {change = 1, node_id = "min_y/text"}
text_field_button_data[hash("max_y_down/bg")] = {change = -1, node_id = "max_y/text"}
text_field_button_data[hash("max_y_up/bg")] = {change = 1, node_id = "max_y/text"}
text_field_button_data[hash("depth_up/bg")] = {change = 1, node_id = "depth/text"}
text_field_button_data[hash("depth_down/bg")] = {change = -1, node_id = "depth/text"}
text_field_button_data[hash("offset_x_down/bg")] = {change = -1, node_id = "offset_x/text"}
text_field_button_data[hash("offset_x_up/bg")] = {change = 1, node_id = "offset_x/text"}
text_field_button_data[hash("offset_y_down/bg")] = {change = -1, node_id = "offset_y/text"}
text_field_button_data[hash("offset_y_up/bg")] = {change = 1, node_id = "offset_y/text"}

local function on_pressed(button)
	if button.node_id == hash("load_images/bg") then
		load_images()
	elseif button.node_id == hash("create/bg") then
		if #image_data < 1 then
			gui.set_text(message_box, "No images loaded.")
		elseif not (create_additive or create_subtractive) then
			gui.set_text(message_box, "No volumes created. Select additive or subtractive to generate volumes.")
		else
			volumes = {}
			local group_index = starting_group_index
			if delete_walkway then
				group_index = group_index + 1
			end
			for index, val in ipairs(image_data) do
				if divide_picture(index, group_index) and separate_group_index then
					group_index = group_index + 1
				end
			end
			if #volumes > 1 then
				gui.set_text(message_box, #volumes.." volumes created.")
			elseif #volumes == 1 then
				gui.set_text(message_box, "One volume created.")
			else
				gui.set_text(message_box, "No volumes created for some reason.")
			end
			local output_string = ""
			for key, val in ipairs(volumes) do
				output_string = output_string..val
				if key < #volumes then
					output_string = output_string..","
				end
			end
			local f
			if delete_walkway then
				f = io.output("output/volume_data.txt")
				io.write(walkway..output_string)
				io.close(f)
				f = io.output("output/do_not_ship.pw_meta")
				io.write(string_start..walkway..output_string..string_end)
				io.close(f)
			else
				f = io.output("output/volume_data.txt")
				io.write(output_string)
				io.close(f)
				f = io.output("output/do_not_ship.pw_meta")
				io.write(string_start..output_string..string_end)
				io.close(f)
			end
		end
	elseif button.node_id == hash("left/bg") then
		if current_preview > 1 then
			current_preview = current_preview - 1
			set_preview_image()
		end
	elseif button.node_id == hash("right/bg") then
		if current_preview < #image_data then
			current_preview = current_preview + 1
			set_preview_image()
		end
	elseif text_field_button_data[button.node_id] then
		local data = text_field_button_data[button.node_id]
		local new_val = node_text_to_number(data.node_id) + data.change
		update_input({node_id = hash(data.node_id), text = tostring(new_val)})
	elseif button.node_id == hash("mode/bg") then
		msg.post(".", hash("disable"))
		msg.post("#material_changer", hash("enable"))
	end
end


function on_input(self, action_id, action)
	dirtylarry.button("mode", action_id, action, on_pressed, update_button)
	dirtylarry.button("load_images", action_id, action, on_pressed, update_button)
	dirtylarry.button("create", action_id, action, on_pressed, update_button)
	dirtylarry.button("left", action_id, action, on_pressed, update_button)
	dirtylarry.button("right", action_id, action, on_pressed, update_button)
	dirtylarry.checkbox("additive", action_id, action, on_checked, update_checkbox)
	dirtylarry.checkbox("subtractive", action_id, action, on_checked, update_checkbox)
	dirtylarry.checkbox("invert", action_id, action, on_checked, update_checkbox)
	dirtylarry.checkbox("image_group", action_id, action, on_checked, update_checkbox)
	local text_config = {max_length = 3, allowed_characters ="[%d-]"}
	dirtylarry_input("depth", gui.KEYBOARD_TYPE_DEFAULT, action_id, action, text_config, update_input)
	dirtylarry_input("min_x", gui.KEYBOARD_TYPE_DEFAULT, action_id, action, text_config, update_input)
	dirtylarry_input("max_x", gui.KEYBOARD_TYPE_DEFAULT, action_id, action, text_config, update_input)
	dirtylarry_input("min_y", gui.KEYBOARD_TYPE_DEFAULT, action_id, action, text_config, update_input)
	dirtylarry_input("max_y", gui.KEYBOARD_TYPE_DEFAULT, action_id, action, text_config, update_input)
	dirtylarry_input("group_index", gui.KEYBOARD_TYPE_DEFAULT, action_id, action, text_config, update_input)
	dirtylarry_input("processing_order", gui.KEYBOARD_TYPE_DEFAULT, action_id, action, {max_length = 4, allowed_characters ="[%d]"}, update_input)
	dirtylarry.button("min_x_down", action_id, action, on_pressed, update_button)
	dirtylarry.button("min_x_up", action_id, action, on_pressed, update_button)
	dirtylarry.button("max_x_down", action_id, action, on_pressed, update_button)
	dirtylarry.button("max_x_up", action_id, action, on_pressed, update_button)
	dirtylarry.button("min_y_down", action_id, action, on_pressed, update_button)
	dirtylarry.button("min_y_up", action_id, action, on_pressed, update_button)
	dirtylarry.button("max_y_down", action_id, action, on_pressed, update_button)
	dirtylarry.button("max_y_up", action_id, action, on_pressed, update_button)
	dirtylarry.button("depth_up", action_id, action, on_pressed, update_button)
	dirtylarry.button("depth_down", action_id, action, on_pressed, update_button)
	dirtylarry_input("offset_x", gui.KEYBOARD_TYPE_DEFAULT, action_id, action, text_config, update_input)
	dirtylarry_input("offset_y", gui.KEYBOARD_TYPE_DEFAULT, action_id, action, text_config, update_input)
	dirtylarry.button("offset_x_up", action_id, action, on_pressed, update_button)
	dirtylarry.button("offset_x_down", action_id, action, on_pressed, update_button)
	dirtylarry.button("offset_y_up", action_id, action, on_pressed, update_button)
	dirtylarry.button("offset_y_down", action_id, action, on_pressed, update_button)
	dirtylarry.checkbox("show_path", action_id, action, on_checked, update_checkbox)

	dirtylarry.radiogroup("filter", action_id, action, function(group_id, action_id, action)
		dirtylarry.radio("filter_white", group_id, action_id, action, function(radio)
			filter = 0
		end)
		dirtylarry.radio("filter_alpha", group_id, action_id, action, function(radio)
			filter = 3
		end)
	end)
end