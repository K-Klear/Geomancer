local UI = require("modules/ui")

local model_list = {}
local part_names = {[false] = {}}
local selected_model = false
local selected_model_index
local selected_part_index
local current_material

local model_names = {}

local string_colours
local string_static_props
local string_culling_ranges
local table_culling_ranges
local string_dictionary
local model_strings = {}
local custom_material = "(DoNotEdit)LiveMat_"

local filename, overwrite

local button_highlight, part_highligh, model_highlight
local model_page = 0
local model_page_max = 0
local part_page = 0
local part_page_max = 0

local function enable_page_buttons(model_pages, enabled)
	if model_pages then
		gui.set_enabled(gui.get_node("model_page_up/button_white"), enabled)
		gui.set_enabled(gui.get_node("model_page_down/button_white"), enabled)
		gui.set_enabled(gui.get_node("model_page"), enabled)
		if enabled then
			UI.load_template({"model_page_up", "model_page_down"})
		else
			UI.unload_template({"model_page_up", "model_page_down"})
		end
	else
		gui.set_enabled(gui.get_node("part_page_up/button_white"), enabled)
		gui.set_enabled(gui.get_node("part_page_down/button_white"), enabled)
		gui.set_enabled(gui.get_node("part_page"), enabled)
		if enabled then
			UI.load_template({"part_page_up", "part_page_down"})
		else
			UI.unload_template({"part_page_up", "part_page_down"})
		end
	end
end

local highlight_position = {}

local materials = {}
materials.props = "(DoNotEdit)LiveMat_Props"
materials.geo_simple = "(DoNotEdit)LiveMat_LevelGeoSimple"
materials.glow = "(DoNotEdit)LiveMat_Glow"
materials.glow_invert = "(DoNotEdit)LiveMat_GlowInvert"
materials.peds_alt = "(DoNotEdit)LiveMat_PedestriansAlt"
materials.megahit = "(DoNotEdit)LiveMat_MegaHitTrail"
materials.enemy_glow = "(DoNotEdit)LiveMat_EnemyGlow"
materials.squirtgun = "(DoNotEdit)LiveMat_Squirtgun_drops"
materials.ring_outer = "(DoNotEdit)LiveMat_PlayerRingOuter2"
materials.gunmat = "(DoNotEdit)LiveMat_Gunmat New Three Color"
materials.dissolve = "(DoNotEdit)LiveMat_Pedestrians_Dissolve"

function init(self)
	msg.post("#", hash("disable"))
	button_highlight = gui.get_node("button_highlight")
	model_highlight = gui.get_node("model_highlight")
	part_highlight = gui.get_node("part_highlight")
	for i = 1, 10 do
		gui.set_enabled(gui.get_node("model_list_"..tonumber(i).."/button_white"), false)
		gui.set_enabled(gui.get_node("part_list_"..tonumber(i).."/button_white"), false)
		gui.set_enabled(gui.get_node("dynamic_"..tonumber(i).."/button_white"), false)
	end
	enable_page_buttons(true, false)
	enable_page_buttons(false, false)
	for key, val in pairs(materials) do
		highlight_position[val] = gui.get_position(gui.get_node(key.."/button_white"))
	end
	highlight_position.custom = gui.get_position(gui.get_node("custom/button_white"))
end

local function update_list(list)
	for i,item in ipairs(list.items) do
		gui.set_text(item.nodes[hash("listitem_text")], item.data)
	end
end

local current_name = ""
local current_model = ""

local function find_substring(string, substring, count, index)
	index = index or 1
	repeat
		local found = string.find(string, substring, index)
		if found then
			index = found + 1
			count = count - 1
		else
			return nil
		end
	until count < 1
	return index - 1
end

local function highlight_model()
	if selected_model_index and selected_model_index > (model_page * 10) and (selected_model_index - 1) < (model_page + 1) * 10 then
		local pos = vmath.vector3(250, 800 - (selected_model_index - 1 - (model_page * 10)) * 70, 0)
		gui.set_position(model_highlight, pos)
		gui.set_enabled(model_highlight, true)
	else
		gui.set_enabled(model_highlight, false)
	end
end

local function highlight_part()
	if selected_part_index and selected_part_index > (part_page * 10) and (selected_part_index - 1) < (part_page + 1) * 10 then
		local pos = vmath.vector3(620, 800 - (selected_part_index - 1 - (part_page * 10)) * 70, 0)
		gui.set_position(part_highlight, pos)
		gui.set_enabled(part_highlight, true)
	else
		gui.set_enabled(part_highlight, false)
	end
	if current_material then
		gui.set_enabled(button_highlight, true)
		for key, val in pairs(materials) do
			gui.set_enabled(gui.get_node(key.."/button_white"), true)
			UI.load_template(key)
		end
		gui.set_enabled(gui.get_node("custom/button_white"), true)
		UI.load_template("custom")
		if highlight_position[current_material] then
			gui.set_position(button_highlight, highlight_position[current_material])
		else
			gui.set_position(button_highlight, highlight_position.custom)
			gui.set_text(gui.get_node("custom_mat/text"), current_material)
		end
	else
		gui.set_enabled(button_highlight, false)
		for key, val in pairs(materials) do
			gui.set_enabled(gui.get_node(key.."/button_white"), false)
			UI.unload_template(key)
		end
		gui.set_enabled(gui.get_node("custom/button_white"), true)
		UI.unload_template("custom")
	end
end

local function populate_model_list()
	for i = 1, 10 do
		local template_name = "model_list_"..tostring(i)
		local node_name = template_name.."/button_white"
		local node = gui.get_node(node_name)
		local node_text = gui.get_node(template_name.."/text")
		local model_data = model_list[i + (10 * model_page)]
		
		if model_data then
			gui.set_enabled(node, true)
			gui.set_text(node_text, model_data.name)
			UI.load_template(template_name)
			template_name = "dynamic_"..tostring(i)
			gui.set_enabled(gui.get_node(template_name.."/button_white"), true)
			if model_data.dynamic then
				gui.set_text(gui.get_node(template_name.."/text"), "X")
			else
				gui.set_text(gui.get_node(template_name.."/text"), "")
			end
			UI.load_template(template_name)
		else
			gui.set_enabled(node, false)
			gui.set_text(node_text, "")
			UI.unload_template(template_name)
			template_name = "dynamic_"..tostring(i)
			gui.set_enabled(gui.get_node(template_name.."/button_white"), false)
		end
	end
	gui.set_text(gui.get_node("model_page"), tostring(model_page + 1).."/"..tostring(model_page_max + 1))
	if model_page_max > 0 then
		enable_page_buttons(true, true)
	else
		enable_page_buttons(true, false)
	end
	highlight_model()
end

local function populate_part_list()
	if selected_model then
		part_page_max = math.floor((#part_names[selected_model] - 1) / 10)
	end
	for i = 1, 10 do
		local template_name = "part_list_"..tostring(i)
		local node_name = template_name.."/button_white"
		local node = gui.get_node(node_name)
		local node_text = gui.get_node(template_name.."/text")

		local part_data
		if selected_model then
			part_data = part_names[selected_model][i + (10 * part_page)]
		end

		if part_data then
			gui.set_enabled(node, true)
			gui.set_text(node_text, part_data)
			UI.load_template(template_name)
		else
			gui.set_enabled(node, false)
			gui.set_text(node_text, "")
			UI.unload_template(template_name)
		end
	end
	gui.set_text(gui.get_node("part_page"), tostring(part_page + 1).."/"..tostring(part_page_max + 1))
	if part_page_max > 0 then
		enable_page_buttons(false, true)
	else
		enable_page_buttons(false, false)
	end
	highlight_model()
	highlight_part()
end

local function unload_models()
	model_list = {}
	part_names = {[false] = {}}
	selected_model = false
	selected_model_index = nil
	selected_part_index = nil
	current_material = nil
	model_names = {}
	string_colours = nil
	string_static_props = nil
	string_culling_ranges = nil
	table_culling_ranges = nil
	string_dictionary = nil
	model_strings = {}
	custom_material = "(DoNotEdit)LiveMat_"
	filename = nil
	model_page = 0
	model_page_max = 0
	part_page = 0
	part_page_max = 0
	populate_model_list()
	populate_part_list()
end

local function load_models(path)
	local function find_section(tab, model_index)
		if type(tab) == "table" then
			if tab.name then
				current_name = tab.name
			end
			if tab.materials then
				for key, val in ipairs(tab.materials) do
					table.insert(model_list[model_index].parts, val)
					table.insert(part_names[current_model], current_name)
				end
			else
				for key, val in pairs(tab) do
					find_section(val, model_index)
				end
			end
		end
	end

	local f = io.open(path, "rb")
	if f then
		local full_string = f:read("*a")
		local tab = json.decode(full_string)
		table_culling_ranges = tab.staticCullingRanges
		model_list = {}
		model_names = {}
		part_names = {[false] = {}}
		for k, v in ipairs(tab.propsDictionary) do
			if k > 1 and v.key then
				table.insert(model_names, v.key)
				table.insert(model_list, {name = v.key, parts = {}, dynamic = false})
				current_model = v.key
				part_names[current_model] = {}
				find_section(v, #model_list)
			end
		end
		model_page = 0
		model_page_max = math.floor((#model_list - 1) / 10) 

		populate_model_list()

		local staticProps_start = string.find(full_string, "staticProps")
		local ranges_start = string.find(full_string, "staticCullingRanges")
		local dictionary_start = string.find(full_string, "propsDictionary")

		if not staticProps_start then
			return
		end

		string_colours = string.sub(full_string, 1, staticProps_start - 2)
		string_static_props = string.sub(full_string, staticProps_start - 1, ranges_start - 2)
		string_culling_ranges = string.sub(full_string, ranges_start - 1, dictionary_start - 2)
		local string_props_dictionary = string.sub(full_string, dictionary_start - 1)
		
		--string_beginning = string.sub(full_string, 1, dictionary_start + 1016)

		local start_index = 1018
		local search_string = "{\"key"

		local key_indices = {}
		local safety = 1000
		repeat
			local next_key_index = string.find(string_props_dictionary, search_string, start_index)
			if next_key_index then
				table.insert(key_indices, next_key_index)
				start_index = next_key_index + 5
			end
			safety = safety - 1
			if safety < 1 then
				print("fucked that up")
				break
			end
		until not next_key_index
		for i = 1, #key_indices - 1 do
			model_list[i].string = string.sub(string_props_dictionary, key_indices[i], key_indices[i + 1] - 2)
		end
		string_dictionary = string.sub(string_props_dictionary, 1, key_indices[1] - 1)
		model_list[#key_indices].string = string.sub(string_props_dictionary, key_indices[#key_indices], -3)
		io.close(f)
	end
end

local function sort_models()
	table.sort(model_names, function(a, b) return string.lower(a) < string.lower(b) end)
	table.sort(model_list, function(a, b) return string.lower(a.name) < string.lower(b.name) end)
	if selected_model then
		for key, val in ipairs(model_names) do
			if val == selected_model then
				selected_model_index = key
				break
			end
		end
	end
	populate_model_list()
end

local function export_models(path)
	
	local dynamic_props_list = {}
	local dynamic_ranges_list = {}

	local dynamic_props = "\"dynamicProps\":["
	local create_dynamic_props

	for key, val in ipairs(model_list) do
		local model_name = "\""..val.name.."\""
		if val.dynamic then
			create_dynamic_props = true
			local found
			local search_index = 1
			local first = true
			repeat
				found = string.find(string_static_props, model_name, search_index)
				if found then
					if not first then
						string_static_props = string_static_props..","
						first = nil
					end
					local closing_bracket = string.find(string_static_props, "}", found)
					table.insert(dynamic_props_list, string.sub(string_static_props, found - 8, closing_bracket))
					string_static_props = string.sub(string_static_props, 1, found - 9)..string.sub(string_static_props, closing_bracket + 2)
					search_index = found - 8
				end
			until not found
			if string.sub(string_static_props, -2) == ",," then
				string_static_props = string.sub(string_static_props, 1, -3).."],"
			end
		end
		for k, v in ipairs(table_culling_ranges) do
			for _k, _v in ipairs(v.members) do
				if _v.name == val.name and val.dynamic then
					create_dynamic_props = true
					dynamic_ranges_list[v.range] = dynamic_ranges_list[v.range] or {}
					table.insert(dynamic_ranges_list[v.range], model_name)
				end
			end
		end

		if key < #model_list then
			string_dictionary = string_dictionary..val.string..","
		else
			string_dictionary = string_dictionary..val.string
		end
	end

	local dynamic_ranges = "\"dynamicCullingRanges\":["

	if create_dynamic_props then
		for key, val in ipairs(dynamic_props_list) do
			dynamic_props = dynamic_props..val
			if key < #dynamic_props_list then
				dynamic_props = dynamic_props..","
			end
		end
		local dynamic_ranges_array = {}
		for key, val in pairs(dynamic_ranges_list) do
			table.insert(dynamic_ranges_array, {range = key, names = val})
		end
		local function find_range_start(range)
			return tonumber(string.sub(range, 1, string.find(range, ",") - 1))
		end
		table.sort(dynamic_ranges_array, function(a, b) return find_range_start(a.range) < find_range_start(b.range) end)
		local final_range_done = false
		for key, val in ipairs(dynamic_ranges_array) do
			dynamic_ranges = dynamic_ranges.."{\"range\":\""..val.range.."\",\"members\":["
			local range_index = string.find(string_culling_ranges, val.range)
			for k, v in ipairs(val.names) do
				local prop_index = string.find(string_culling_ranges, v, range_index)
				local closing_bracket = string.find(string_culling_ranges, "}", prop_index)
				dynamic_ranges = dynamic_ranges..string.sub(string_culling_ranges, prop_index - 8, closing_bracket)
				if k == #val.names then
					if key == #dynamic_ranges_array then
						dynamic_ranges = dynamic_ranges.."]}"
					else
						dynamic_ranges = dynamic_ranges.."]},"
					end
					local member_count
					for _, rt in ipairs(table_culling_ranges) do
						if val.range == rt.range then
							member_count = #rt.members
							break
						end
					end
					if #val.names == member_count then
						if string.sub(string_culling_ranges, closing_bracket + 3, closing_bracket + 3) == "," then
							string_culling_ranges = string.sub(string_culling_ranges, 1, range_index - 11)..string.sub(string_culling_ranges, closing_bracket + 4)
						else
							string_culling_ranges = string.sub(string_culling_ranges, 1, range_index - 11)..string.sub(string_culling_ranges, closing_bracket + 3)
							final_range_done = true
						end
					else
						if string.sub(string_culling_ranges, closing_bracket + 3, closing_bracket + 3) == "," then
							string_culling_ranges = string.sub(string_culling_ranges, 1, prop_index - 9)..string.sub(string_culling_ranges, closing_bracket + 3)
						else
							string_culling_ranges = string.sub(string_culling_ranges, 1, prop_index - 9)..string.sub(string_culling_ranges, closing_bracket + 2)
							--final_range_done = true
						end
					end
				else
					dynamic_ranges = dynamic_ranges..","
					if string.sub(string_culling_ranges, closing_bracket + 1, closing_bracket + 1) == "," then
						string_culling_ranges = string.sub(string_culling_ranges, 1, prop_index - 9)..string.sub(string_culling_ranges, closing_bracket + 2)
					else
						string_culling_ranges = string.sub(string_culling_ranges, 1, prop_index - 9)..string.sub(string_culling_ranges, closing_bracket + 1)
					end
				end
			end
			local double_comma = string.find(string_culling_ranges, ",,")
			if double_comma then
				string_culling_ranges = string.sub(string_culling_ranges, 1, double_comma - 1).."]}"..string.sub(string_culling_ranges, double_comma + 1)
			end
		end
		if final_range_done then
			string_culling_ranges = string.sub(string_culling_ranges, 1, -4).."],"
		end
		if #string_culling_ranges < 25 then
			string_culling_ranges = "\"staticCullingRanges\":[],"
		end
	end
	local final_string = string_colours..string_static_props..string_culling_ranges
	if create_dynamic_props then
		final_string = final_string..dynamic_props.."],"..dynamic_ranges.."],"
	end
	
	final_string = final_string..string_dictionary

	local file_exists = sys.exists(path..filename)
	local f
	if file_exists and not overwrite then
		f = io.output(path..filename.."_modified")
	else
		f = io.output(path..filename)
	end
	io.write(final_string.."]}")
	io.close(f)
	unload_models()
end

local function update_input(input)
	if input.node_id == hash("custom_mat/text") then
		custom_material = input.text
	end
end

local function evaluate_input(field, text)
	custom_material = text
end

local function evaluate_button(button)
	if button == "models_main_menu" then
		unload_models()
		msg.post(".", hash("disable"))
		UI.unload_template()
		msg.post("#splash", hash("mode_switched"))
	elseif button == "load_models" then
		local num, path = diags.open("pw_art")
		if path then
			local htap = string.reverse(path)
			filename = string.reverse(string.sub(htap, 1, string.find(htap, "\\")))
			load_models(path)
		end
	elseif button == "sort" then
		sort_models()
	elseif button == "export" and filename then
		local num, path = diags.open_folder()
		if path then
			export_models(path)
		end
	elseif button == "model_page_up" then
		if model_page < model_page_max then
			model_page = model_page + 1
			populate_model_list()
		end
	elseif button == "model_page_down" then
		if model_page > 0 then
			model_page = model_page - 1
			populate_model_list()
		end
	elseif button == "part_page_up" then
		if part_page < part_page_max then
			part_page = part_page + 1
			populate_part_list()
		end
	elseif button == "part_page_down" then
		if part_page > 0 then
			part_page = part_page - 1
			populate_part_list()
		end
	elseif materials[button] then
		local model_tab = model_list[selected_model_index]
		local str_start = find_substring(model_tab.string, "(DoNotEdit)", selected_part_index) - 2
		local str_end = str_start + #current_material + 1
		current_material = materials[button]
		model_tab.parts[selected_part_index] = current_material
		model_tab.string = string.sub(model_tab.string, 1, str_start)..current_material..string.sub(model_tab.string, str_end)
		highlight_part()
	elseif button == "custom" then
		local model_tab = model_list[selected_model_index]
		local str_start = find_substring(model_tab.string, "(DoNotEdit)", selected_part_index) - 2
		local str_end = str_start + #current_material + 1
		current_material = custom_material
		model_tab.parts[selected_part_index] = current_material
		model_tab.string = string.sub(model_tab.string, 1, str_start)..current_material..string.sub(model_tab.string, str_end)
		highlight_part()
	elseif button == "overwrite_models" then
		overwrite = not overwrite
		if overwrite then
			gui.set_text(gui.get_node("overwrite_models/text"), "X")
		else
			gui.set_text(gui.get_node("overwrite_models/text"), "")
		end
	else
		for i = 1, 10 do
			if button == "model_list_"..i then
				selected_model_index = i + (10 * model_page)
				selected_model = model_list[selected_model_index].name
				part_page = 0
				selected_part_index = 1
				current_material = model_list[selected_model_index].parts[selected_part_index]
				populate_part_list()
				highlight_part()
				break
			elseif button == "part_list_"..i then
				selected_part_index = i + (10 * part_page)
				current_material = model_list[selected_model_index].parts[selected_part_index]
				highlight_part()
				break
			elseif button == "dynamic_"..i then
				if model_list[i + (10 * model_page)].dynamic then
					model_list[i + (10 * model_page)].dynamic = false
					gui.set_text(gui.get_node("dynamic_"..i.."/text"), "")
				else
					model_list[i + (10 * model_page)].dynamic = true
					gui.set_text(gui.get_node("dynamic_"..i.."/text"), "X")
				end
			end
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("mode_switched") then
		local button_list = {"models_main_menu", "load_models", "sort", "export", "overwrite_models"}
		UI.load_template(button_list)
		UI.load_text_field("custom_mat", 46)
		msg.post("#", hash("enable"))
		UI.input_enabled = true
	end
end

function on_input(self, action_id, action)
	UI.on_input(self, action_id, action, evaluate_button, evaluate_input)
end