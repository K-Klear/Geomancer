local MEM = require "modules.memory"
local SET = require "modules.settings"
local G = require "modules.global"
local MOD = require "modules.models"
local COL = require "modules.colours"

local MODEL_CAMERA = "/model_camera"
local CAMERA_TARGET = "/camera_target"
local GROUND_GO = "/ground"

local TWEEN_ACTION_WAIT = hash("W")
local TWEEN_ACTION_MOVE = hash("T")
local TWEEN_ACTION_SCALE = hash("S")
local TWEEN_ACTION_ROTATE = hash("R")

local TEMPO_SECTION = hash("tempo_section")
local NOBEAT_START = hash("nobeat_start")
local NOBEAT_END = hash("nobeat_end")


local material_list = {}

go.property("geo_material", resource.material("/render/prop_materials/geo.material"))

go.property("shader_prop", resource.material("/render/prop_materials/prop.material"))
go.property("shader_glow", resource.material("/render/prop_materials/glow.material"))
go.property("shader_pure_colour", resource.material("/render/prop_materials/pure_colour.material"))
go.property("shader_transparent", resource.material("/render/prop_materials/transparent.material"))
go.property("shader_geo_simple", resource.material("/render/prop_materials/geo_simple.material"))
go.property("shader_dissolve", resource.material("/render/prop_materials/dissolve.material"))
go.property("shader_ped", resource.material("/render/prop_materials/pedestrian.material"))
go.property("shader_beatcubes", resource.material("/render/prop_materials/beatcubes.material"))
go.property("shader_geo_complex", resource.material("/render/prop_materials/geo_complex.material"))
go.property("shader_ring", resource.material("/render/prop_materials/ring.material"))
go.property("shader_gunmat", resource.material("/render/prop_materials/gunmat.material"))
go.property("shader_megahit", resource.material("/render/prop_materials/megahit.material"))
go.property("shader_boss", resource.material("/render/prop_materials/boss.material"))
go.property("shader_enemy", resource.material("/render/prop_materials/enemy.material"))
go.property("shader_shield", resource.material("/render/prop_materials/shield.material"))
go.property("shader_dead_body", resource.material("/render/prop_materials/dead_body.material"))
go.property("shader_continental", resource.material("/render/prop_materials/continental.material"))
go.property("shader_mr_obstacle", resource.material("/render/prop_materials/mr_obstacle.material"))
go.property("shader_glow_mult", resource.material("/render/prop_materials/glow_mult.material"))
go.property("shader_targets", resource.material("/render/prop_materials/targets.material"))

go.property("shader_flash", resource.material("/render/other_materials/flash.material"))

go.property("geo_floor_tex", resource.texture("/assets/gfx/textures/default_floor.png"))
go.property("prop_tex", resource.texture("/assets/gfx/textures/prop.png"))
go.property("cont_1_tex", resource.texture("/assets/gfx/textures/continental_1.png"))
go.property("cont_2_tex", resource.texture("/assets/gfx/textures/continental_2.png"))
go.property("shield_tex", resource.texture("/assets/gfx/textures/shielded.png"))
go.property("ped_tex", resource.texture("/assets/gfx/textures/peds.png"))

go.property("grid_mat", resource.material("/render/other_materials/grid_repeat.material"))
go.property("grid_mat_overdraw", resource.material("/render/other_materials/grid_repeat_overdraw.material"))


local created_meshes = {}
local created_transforms = {}
local geo_meshes = {}
local chunk_meshes = {}
local static_meshes = {}
local beatcubes = {}
local preview_model = {}
local preview_model_transforms = {}
local preview_model_flash = {}

local current_culling_range, previous_culling_range = 0, nil
local current_colour = 1
local c1, c2 = {}, {}
local colour_transition, ct_clamped

local whiteout_in_progress, beat_in_progress = false, false
local beat_duration = 0.2
local desync_check_scrubber
local desync_check_playtime

local tween_padding_start = 0

local active_tweens = {}

local CAMERA_POSITION = vmath.vector3(0, 1.75, 0)

local function show_grid(self)
	if SET.model_show_grid == 1 then
		msg.post("/grid#grid", hash("enable"))
		go.set("/grid#grid", "material", self.grid_mat_overdraw)
	elseif SET.model_show_grid == 2 then
		msg.post("/grid#grid", hash("enable"))
		go.set("/grid#grid", "material", self.grid_mat)
	else
		msg.post("/grid#grid", hash("disable"))
	end
end

local function fill_material_list(self)
	material_list = {
		-- default
		["(DoNotEdit)LiveMat_Props"] = {colour = "main", texture = self.ped_tex, shader = self.shader_prop, fog = true, whiteout = true, extra_glow = true},
		["(DoNotEdit)LiveMat_LevelGeoSimple"] = {colour = "main", texture = self.prop_tex, shader = self.shader_geo_simple, fog = true},
		["(DoNotEdit)LiveMat_Glow"] = {colour = "glow", shader = self.shader_glow, fog = true},
		["(DoNotEdit)LiveMat_GlowInvert"] = {colour = "glow_inv", shader = self.shader_glow, fog = true},
		--variants of standard
		["(DoNotEdit)LiveMat_Pedestrians_Dissolve"] = {colour = "fog", shader = self.shader_dissolve},
		["(DoNotEdit)LiveMat_Continental Interior 1"] = {colour = "main", texture = self.cont_1_tex, shader = self.shader_continental, fog = true},
		["(DoNotEdit)LiveMat_Continental Interior 2"] = {colour = "main", texture = self.cont_2_tex, shader = self.shader_continental, fog = true},
		["(DoNotEdit)LiveMat_FrontEnd_Building"] = {colour = "main", texture = self.cont_1_tex, shader = self.shader_continental, flash = true, fog = true},
		["(DoNotEdit)LiveMat_LevelGeoComplex"] = {colour = "main", texture = self.prop_tex, texture_2 = self.geo_floor_tex, shader = self.shader_geo_complex, fog = true, flash = true},
		["(DoNotEdit)LiveMat_Enemies_Targets"] = {colour = "enemy", texture = self.ped_tex, shader = self.shader_targets, flash = true},
		--white
		["(DoNotEdit)LiveMat_EnemyGlow"] = {colour = vmath.vector4(1, 1, 1, 1), shader = self.shader_pure_colour},
		["(DoNotEdit)LiveMat_EnemyGlow_Gun"] = {colour = vmath.vector4(1, 1, 1, 1), shader = self.shader_pure_colour},
		["(DoNotEdit)LiveMat_ParticleMesh_EnviroColor"] = {colour = vmath.vector4(1, 1, 1, 1), shader = self.shader_pure_colour},
		["(DoNotEdit)LiveMat_ParticleMesh_Glow"] = {colour = vmath.vector4(1, 1, 1, 1), shader = self.shader_pure_colour},
		--black
		["(DoNotEdit)LiveMat_MegaHitTrail"] = {colour = "glow", shader = self.shader_megahit},
		["(DoNotEdit)LiveMat_Gunmat New Three Color"] = {shader = self.shader_gunmat},
		--transparent
		["(DoNotEdit)LiveMat_Player_MuzzleFlashSquirtgun"] = {colour = "fog", shader = self.shader_transparent},
		["(DoNotEdit)LiveMat_Squirtgun_drops"] = {colour = "fog", shader = self.shader_transparent},
		-- combinations
		["(DoNotEdit)LiveMat_Obstacles"] = {colour = "main", texture = self.ped_tex, shader = self.shader_prop, fog = true, flash = true, extra_glow = true},
		["(DoNotEdit)LiveMat_MRObstacles"] = {colour = "main", texture = self.ped_tex, shader = self.shader_mr_obstacle, fog = true, flash = true, extra_glow = true},
		["(DoNotEdit)LiveMat_Props_NoDistortion"] = {colour = "main", texture = self.ped_tex, shader = self.shader_prop, fog = true, flash = true, extra_glow = true},
		["(DoNotEdit)LiveMat_ParticleMesh_GlowMultiply"] = {colour = "glow", shader = self.shader_glow_mult, fog = true},
		["(DoNotEdit)LiveMat_Pedestrians"] = {colour = "main", texture = self.ped_tex, shader = self.shader_ped, flash = true, fog = true, extra_glow = true},
		["(DoNotEdit)LiveMat_PedestriansAlt"] = {colour = "enemy", texture = self.ped_tex, shader = self.shader_ped, fog = true, extra_glow = true},
		-- unique
		["(DoNotEdit)LiveMat_Enemies_Shielded"] = {texture = self.shield_tex, shader = self.shader_shield, flash = true},
		["(DoNotEdit)LiveMat_Beatcubes_mat"] = {colour = "glow", shader = self.shader_beatcubes, fog = true, flash = true},
		["(DoNotEdit)LiveMat_Enemies_DeadBody"] = {colour = "enemy", texture = self.ped_tex, shader = self.shader_dead_body, fog = true},

		-- chaotic
		["(DoNotEdit)LiveMat_Enemies"] = {colour = "enemy", texture = self.ped_tex, shader = self.shader_enemy, flash = true},
		["(DoNotEdit)LiveMat_Boss"] = {colour = "enemy", texture = self.ped_tex, shader = self.shader_boss, flash = true, fog = true},
		["(DoNotEdit)LiveMat_PlayerRingOuter2"] = {texture = self.ped_tex, shader = self.shader_ring, flash = true},
	}
end

function init(self)
	msg.post(".", hash("disable"))
	msg.post("/fog#fog", hash("disable"))
	msg.post("/grid#grid", hash("disable"))
	fill_material_list(self)
end

local flash_timer, flash_on, flash_off
local flash_list = {}
function flash_off()
	if SET.mesh_flash_frequency > 0 then
		for key, val in pairs(flash_list) do
			msg.post(preview_model[val].url, hash("enable"))
			msg.post(preview_model_flash[val].url, hash("disable"))
		end
		if flash_timer then
			timer.cancel(flash_timer)
		end
		flash_timer = timer.delay(SET.mesh_flash_frequency, false, flash_on)
	end
end

function flash_on()
	if flash_timer then
		timer.cancel(flash_timer)
	end
	if SET.mesh_flash_time == 0 then return end
	for key, val in ipairs(flash_list) do
		msg.post(preview_model[val].url, hash("disable"))
		msg.post(preview_model_flash[val].url, hash("enable"))
	end
	flash_timer = timer.delay(SET.mesh_flash_time, false, flash_off)
end

local function stop_flash()
	if flash_timer then
		timer.cancel(flash_timer)
		flash_timer = nil
	end
	for key, val in ipairs(flash_list) do
		msg.post(preview_model[val].url, hash("enable"))
		msg.post(preview_model_flash[val].url, hash("disable"))
	end
	flash_list = {}
end

local function flash(list)
	stop_flash()
	for key, val in ipairs(list) do
		msg.post(preview_model[val].url, hash("disable"))
		msg.post(preview_model_flash[val].url, hash("enable"))
		table.insert(flash_list, val)
	end
	if #list > 0 then
		flash_on()
	end
end


local function create_chunk_model(self, chunk_tab)
	local new_mesh = factory.create("#create_mesh")
	if not (SET.hide_geo == 2) then
		msg.post(new_mesh, hash("disable"))
	end
	table.insert(chunk_meshes, {mesh = new_mesh, buffer_resource = chunk_tab.buffer_resource})
	go.set_parent(new_mesh, "/geo_base")
	local _url = msg.url(nil, new_mesh, "mesh")
	go.set(_url, "vertices", chunk_tab.buffer_resource)
	go.set(_url, "material", self.shader_pure_colour)
	go.set(_url, "tint1", SET.collider_colour)

	MOD.buffer_resource_used(chunk_tab.buffer_resource)

	go.set_position(vmath.vector3(16 * chunk_tab.id[1], 16 * chunk_tab.id[2], 16 * chunk_tab.id[3]), new_mesh)
	return new_mesh
end

local function create_slice_model(self, slice_tab)
	local new_mesh = factory.create("#create_mesh")
	if SET.hide_geo > 1 then
		msg.post(new_mesh, hash("disable"))
	end
	table.insert(geo_meshes, {mesh = new_mesh, buffer_resource = slice_tab.buffer_resource})
	go.set_parent(new_mesh, "/geo_base")
	local _url = msg.url(nil, new_mesh, "mesh")
	go.set(_url, "vertices", slice_tab.buffer_resource)
	go.set(_url, "texture0", self.prop_tex)
	go.set(_url, "texture1", self.geo_floor_tex)
	go.set(_url, "material", self.geo_material)
	
	MOD.buffer_resource_used(slice_tab.buffer_resource)

	go.set_position(vmath.vector3(0, 0, 16 * slice_tab.id), new_mesh)
	return new_mesh
end

local function get_parent(transform_index, transform_list)
	if transform_index < 2 then return false end
	local parent_tab = transform_list[transform_index].parent_tab
	for i = transform_index - 1, 1, -1 do
		if transform_list[i] == parent_tab then
			return i
		end
	end
end

local function set_material(self, mesh_url, material)
	local mat_props = material_list[material]
	go.set(mesh_url, "material", mat_props.shader)
	local mesh_props
	if type(mat_props.colour) == "string" then
		go.set(mesh_url, "tint1", c1[mat_props.colour])
		go.set(mesh_url, "tint1.w", ct_clamped)
		go.set(mesh_url, "tint2", c2[mat_props.colour])
		if mat_props.fog then
			go.set(mesh_url, "fog1", c1.fog)
			go.set(mesh_url, "fog2", c2.fog)
			if SET.hide_fog then
				go.set(mesh_url, "fog2.w", 0)
			end
		end
		if mat_props.extra_glow then
			go.set(mesh_url, "glow1", c1.glow)
			go.set(mesh_url, "glow2", c2.glow)
		end
		mesh_props = {url = mesh_url, colour = mat_props.colour, fog = mat_props.fog, flash = mat_props.flash, whiteout = mat_props.whiteout, extra_glow = mat_props.extra_glow}
	elseif mat_props.colour then
		go.set(mesh_url, "tint1", mat_props.colour)
		mesh_props = {url = mesh_url, fog = mat_props.fog, flash = mat_props.flash, whiteout = mat_props.whiteout}
	else
		mesh_props = {url = mesh_url, fog = mat_props.fog, flash = mat_props.flash, whiteout = mat_props.whiteout}
	end
	if mat_props.texture then 
		go.set(mesh_url, "texture0", mat_props.texture)
	end
	if mat_props.texture_2 then
		go.set(mesh_url, "texture1", self.geo_floor_tex)
	end
	return mesh_props
end

local function create_prop(self, prop_tab, mesh_flash, create_transform_models)
	local new_base = factory.create("#create_transform_invisible", prop_tab.position, prop_tab.rotation, nil, prop_tab.scale)
	table.insert(static_meshes, {mesh = new_base})
	go.set_parent(new_base, "/static_prop_base")
	local mesh_count = 0
	local transform_list = MEM.art_data.table.propsDictionary[prop_tab.model_index].model_data.transform_list
	local meta_table = {}
	local mesh_list = {}
	local transform_go_list = {}
	
	for key, val in ipairs(transform_list) do
		if key == 1 then
			val.scale = vmath.vector3(1)
			val.position = vmath.vector3(0)
			val.rotation = vmath.quat(0, 0, 0, 1)
		end
		local new_transform = factory.create("#create_transform_invisible", val.position, val.rotation, nil, val.scale)
		table.insert(static_meshes, {mesh = new_transform})
		table.insert(transform_go_list, {url = new_transform, position = val.position, rotation = val.rotation, scale = val.scale})
		if val.parent_tab then
			go.set_parent(new_transform, meta_table[val.parent_tab])
			go.set_position(val.position, new_transform)
		else
			go.set_parent(new_transform, new_base)
		end
		meta_table[val] = new_transform

		if create_transform_models then
			local new_visible_transform = factory.create("#create_transform")
			go.set_parent(new_visible_transform, new_transform)
			table.insert(created_transforms, new_visible_transform)
		end
		
		if val.meshes then
			for k, v in ipairs(val.meshes) do
				mesh_count = mesh_count + 1
				local new_mesh = factory.create("#create_mesh")
				if SET.hide_props or mesh_flash then
					msg.post(new_mesh, hash("disable"))
				end
				go.set_parent(new_mesh, new_transform)
				local _url = msg.url(nil, new_mesh, "mesh")
				if not v.buffer_resource then
					MOD.create_mesh(v)
				end
				table.insert(static_meshes, {mesh = new_mesh, buffer_resource = v.buffer_resource})
				go.set(_url, "vertices", v.buffer_resource)
				MOD.buffer_resource_used(v.buffer_resource)
				local mesh_props
				if mesh_flash then
					go.set(_url, "material", self.shader_flash)
					go.set(_url, "tint", SET.mesh_flash_colour)
					mesh_props = {url = _url}
				else
					local part_tab = MEM.art_data.table.propsDictionary[prop_tab.model_index].model_data.parts[mesh_count]
					mesh_props = set_material(self, _url, part_tab.tab[part_tab.index])
					mesh_props.mesh = new_mesh
				end
				table.insert(mesh_list, mesh_props)
			end
		end
	end
	for key, val in ipairs(prop_tab.signal or {}) do
		val.signal_tab.transforms = transform_go_list
	end
	return mesh_list, transform_go_list
end

local function apply_colours_model()
	c1.main = MOD.colour_override_main or SET.custom_colour_main
	c2.main = MOD.colour_override_main or SET.custom_colour_main
	c1.fog = MOD.colour_override_fog or SET.custom_colour_fog
	c2.fog = MOD.colour_override_fog or SET.custom_colour_fog
	c1.glow = MOD.colour_override_glow or SET.custom_colour_glow
	c2.glow = MOD.colour_override_glow or SET.custom_colour_glow
	c1.enemy = MOD.colour_override_enemy or SET.custom_colour_enemy
	c2.enemy = MOD.colour_override_enemy or SET.custom_colour_enemy
	local h, s, v = COL.rgb_to_hsv(MOD.colour_override_glow or SET.custom_colour_glow)
	h = (h - 0.5) % 1
	local glow_inv = COL.hsv_to_rgb(h, s, v)
	c1.glow_inv = glow_inv
	c2.glow_inv = glow_inv
	for key, val in ipairs(preview_model) do
		if val.colour then
			go.set(val.url, "tint1", c1[val.colour])
			go.set(val.url, "tint2", c2[val.colour])
			if val.fog then
				if SET.hide_fog then
					go.set(val.url, "fog2.w", 0)
				else
					go.set(val.url, "fog1", c1.fog)
					go.set(val.url, "fog2", c2.fog)
				end
			end
			if val.extra_glow then
				go.set(val.url, "glow1", c1.glow)
				go.set(val.url, "glow2", c2.glow)
			end
		end
	end
	go.set("/fog#fog", "tint1", c1.fog)
	go.set("/fog#fog", "tint2", c2.fog)
end

local function override_colour()
	c1.main = MOD.colour_override_main
	c2.main = MOD.colour_override_main
	c1.fog = MOD.colour_override_fog
	c2.fog = MOD.colour_override_fog
	c1.glow = MOD.colour_override_glow
	c2.glow = MOD.colour_override_glow
	c1.enemy = MOD.colour_override_enemy
	c2.enemy = MOD.colour_override_enemy
	for _key in pairs(MOD.culling_ranges.visible_slices) do
		go.set(msg.url(nil, _key.model, "mesh"), "tint1", c1.main)
		go.set(msg.url(nil, _key.model, "mesh"), "tint2", c2.main)
		if SET.hide_fog then
			go.set(msg.url(nil, _key.model, "mesh"), "fog2.w", 0)
		else
			go.set(msg.url(nil, _key.model, "mesh"), "fog1", c1.fog)
			go.set(msg.url(nil, _key.model, "mesh"), "fog2", c2.fog)
		end
	end
	for _key in pairs(MOD.culling_ranges.visible_props) do
		for k, v in ipairs(_key.models) do
			if v.colour then
				go.set(v.url, "tint1", c1[v.colour])
				go.set(v.url, "tint2", c2[v.colour])
				if v.fog then
					if SET.hide_fog then
						go.set(v.url, "fog2.w", 0)
					else
						go.set(v.url, "fog1", c1.fog)
						go.set(v.url, "fog2", c2.fog)
					end
				end
				if v.extra_glow then
					go.set(v.url, "glow1", c1.glow)
					go.set(v.url, "glow2", c2.glow)
				end
			end
		end
	end
	for k, v in ipairs(beatcubes) do
		go.set(v.model_url, "tint1", c1.glow)
		go.set(v.model_url, "tint2", c2.glow)
		if SET.hide_fog then
			go.set(v.model_url, "fog2.w", 0)
		else
			go.set(v.model_url, "fog1", c1.fog)
			go.set(v.model_url, "fog2", c2.fog)
		end
	end
	go.set("/fog#fog", "tint1", c1.fog)
	go.set("/fog#fog", "tint2", c2.fog)
end

local function apply_colour_section(colour_key, t)
	if MOD.colour_override then return end
	local val = MEM.art_data.colour_list[colour_key]
	current_colour = colour_key
	colour_transition = 1 - ((t - val.time) / val.duration)
	ct_clamped = math.max(colour_transition, 0)
	if not (current_colour == MOD.previous_colour) then
		local prev_colour = MEM.art_data.colour_list[colour_key - 1] or MEM.art_data.colour_list[colour_key]
		c1.main = vmath.vector4(val.main)
		c1.main.w = ct_clamped
		c2.main = vmath.vector4(prev_colour.main)
		c1.fog = vmath.vector4(val.fog)
		c1.fog.w = ct_clamped
		c2.fog = vmath.vector4(prev_colour.fog)
		c1.glow = vmath.vector4(val.glow)
		c1.glow.w = ct_clamped
		c2.glow = vmath.vector4(prev_colour.glow)
		c1.enemy = vmath.vector4(val.enemy)
		c1.enemy.w = ct_clamped
		c2.enemy = vmath.vector4(prev_colour.enemy)
		c1.glow_inv = vmath.vector4(val.glow_inv)
		c1.glow_inv.w = ct_clamped
		c2.glow_inv = vmath.vector4(prev_colour.glow_inv)
		for _key in pairs(MOD.culling_ranges.visible_slices) do
			go.set(msg.url(nil, _key.model, "mesh"), "tint1", c1.main)
			go.set(msg.url(nil, _key.model, "mesh"), "tint2", c2.main)
			if SET.hide_fog then
				go.set(msg.url(nil, _key.model, "mesh"), "fog2.w", 0)
			else
				go.set(msg.url(nil, _key.model, "mesh"), "fog1", c1.fog)
				go.set(msg.url(nil, _key.model, "mesh"), "fog2", c2.fog)
			end
		end
		for _key in pairs(MOD.culling_ranges.visible_props) do
			for k, v in ipairs(_key.models) do
				if v.colour then
					go.set(v.url, "tint1", c1[v.colour])
					go.set(v.url, "tint2", c2[v.colour])
					if v.fog then
						if SET.hide_fog then
							go.set(v.url, "fog2.w", 0)
						else
							go.set(v.url, "fog1", c1.fog)
							go.set(v.url, "fog2", c2.fog)
						end
					end
					if v.extra_glow then
						go.set(v.url, "glow1", c1.glow)
						go.set(v.url, "glow2", c2.glow)
					end
				end
			end
		end
		for k, v in ipairs(beatcubes) do
			go.set(v.model_url, "tint1", c1.glow)
			go.set(v.model_url, "tint2", c2.glow)
			if SET.hide_fog then
				go.set(v.model_url, "fog2.w", 0)
			else
				go.set(v.model_url, "fog1", c1.fog)
				go.set(v.model_url, "fog2", c2.fog)
			end
		end
		go.set("/fog#fog", "tint1", c1.fog)
		go.set("/fog#fog", "tint2", c2.fog)
	elseif colour_transition >= 0 then
		for _key in pairs(MOD.culling_ranges.visible_slices) do
			go.set(msg.url(nil, _key.model, "mesh"), "tint1.w", ct_clamped)
		end
		for _key in pairs(MOD.culling_ranges.visible_props) do
			for k, v in ipairs(_key.models) do
				if v.colour then
					go.set(v.url, "tint1.w", ct_clamped)
				end
			end
		end
		for k, v in ipairs(beatcubes) do
			go.set(v.model_url, "tint1.w", ct_clamped)
		end
		go.set("/fog#fog", "tint1.w", ct_clamped)
	end
end

local function hide_beatcubes(state)
	if state == nil then
		SET.hide_beatcubes = not SET.hide_beatcubes
	else
		SET.hide_beatcubes = state
	end
	if SET.hide_beatcubes then
		for key, val in ipairs(beatcubes) do
			msg.post(val.url, hash("disable"))
		end
	else
		for key, val in ipairs(beatcubes) do
			msg.post(val.url, hash("enable"))
		end
	end
end

local function reset_view(mode)
	MOD.is_dragged = false
	MOD.camera_is_dragged = false
	MOD.target_x = 0
	MOD.target_y = 0
	MOD.cam_target_x = 0
	MOD.cam_target_y = 0
	MOD.cam_target_z = 0
	MOD.cam_zoom = 8
	if mode == hash("model") then
		CAMERA_POSITION = vmath.vector3(0, 0, 0)
		go.set_position(vmath.vector3(0, 0, 0), CAMERA_TARGET)
		MOD.target_y = -25
		go.set_rotation(vmath.quat(0, 0, 0, 1), MODEL_CAMERA)
		msg.post("/player_capsule", hash("disable"))
		go.set(GROUND_GO, "position.z", 0)
		apply_colours_model()
		hide_beatcubes(true)
	elseif mode == hash("preview") then
		if MOD.vacuum_preview then
			msg.post("/player_capsule", hash("disable"))
			CAMERA_POSITION = vmath.vector3(0, 1.75, 10)
			go.set_position(vmath.vector3(0, 0, 0), CAMERA_TARGET)
			go.set(GROUND_GO, "position.z", 0)
			hide_beatcubes(true)
		else
			CAMERA_POSITION = vmath.vector3(0, 1.75, 0)
			go.set_position(vmath.vector3(0, 0, 0), CAMERA_TARGET)
			if MOD.pov_lock then
				msg.post("/player_capsule", hash("disable"))
			else
				msg.post("/player_capsule", hash("enable"))
			end
			hide_beatcubes(false)
			local t = MOD.preview_start + MOD.total_time * MOD.scrubber_progress
			local z = t * 3
			if MOD.stationary then
				go.set(GROUND_GO, "position.z", 0)
				go.set("/player_capsule", "position.z", 0)
			elseif MOD.move_terrain then
				go.set(GROUND_GO, "position.z", -z)
				go.set("/player_capsule", "position.z", 0)
			else
				local pos_z = -z - go.get(GROUND_GO, "position.z")
				go.set("/player_capsule", "position.z", pos_z)
			end
		end
	elseif mode == hash("rotate") then
		go.set_position(vmath.vector3(0, -1.3, 0), CAMERA_TARGET)
		go.set_position(vmath.vector3(0, 1.7, 10), MODEL_CAMERA)
		go.set_rotation(vmath.quat(0, 0, 0, 1), MODEL_CAMERA)
		msg.post("/player_capsule", hash("disable"))
		go.set(GROUND_GO, "position.z", 0)
	end
end

local function show_culling_range(self, range)
	for key, val in ipairs(MOD.culling_ranges[range].slices) do
		if not val.model then
			val.model = create_slice_model(self, val)
			val.enabled = true
			MOD.culling_ranges.visible_slices[val] = true
			go.set(msg.url(nil, val.model, "mesh"), "tint1", vmath.vector4(c1.main.x, c1.main.y, c1.main.z, ct_clamped))
			go.set(msg.url(nil, val.model, "mesh"), "tint2", c2.main)
			if SET.hide_fog then
				go.set(msg.url(nil, val.model, "mesh"), "fog2.w", 0)
			else
				go.set(msg.url(nil, val.model, "mesh"), "fog1", c1.fog)
				go.set(msg.url(nil, val.model, "mesh"), "fog2", c2.fog)
			end
		elseif not val.enabled then
			if SET.hide_geo == 1 then
				msg.post(val.model, hash("enable"))
			end
			val.enabled = true
			MOD.culling_ranges.visible_slices[val] = true
			go.set(msg.url(nil, val.model, "mesh"), "tint1", vmath.vector4(c1.main.x, c1.main.y, c1.main.z, ct_clamped))
			go.set(msg.url(nil, val.model, "mesh"), "tint2", c2.main)
			if SET.hide_fog then
				go.set(msg.url(nil, val.model, "mesh"), "fog2.w", 0)
			else
				go.set(msg.url(nil, val.model, "mesh"), "fog1", c1.fog)
				go.set(msg.url(nil, val.model, "mesh"), "fog2", c2.fog)
			end
		end
	end

	for key, val in pairs(MOD.culling_ranges[range].chunks) do
		if not val.model then
			val.model = create_chunk_model(self, val)
			val.enabled = true
			MOD.culling_ranges.visible_chunks[val] = true
		elseif not val.enabled then
			if SET.hide_geo == 2 then
				msg.post(val.model, hash("enable"))
			end
			val.enabled = true
			MOD.culling_ranges.visible_chunks[val] = true
		end
	end
	
	for key, val in ipairs(MOD.culling_ranges[range].props) do
		if not val.hide then
			if not val.models then
				val.models = create_prop(self, val)
				val.enabled = true
				MOD.culling_ranges.visible_props[val] = true
			elseif not val.enabled then
				for k, v in ipairs(val.models) do
					if not SET.hide_props then
						msg.post(v.mesh, hash("enable"))
					end
					if v.colour then
						go.set(v.url, "tint1", c1[v.colour])
						go.set(v.url, "tint1.w", ct_clamped)
						go.set(v.url, "tint2", c2[v.colour])
						if v.fog then
							if SET.hide_fog then
								go.set(v.url, "fog2.w", 0)
							else
								go.set(v.url, "fog1", c1.fog)
								go.set(v.url, "fog2", c2.fog)
							end
						end
						if v.extra_glow then
							go.set(v.url, "glow1", c1.glow)
							go.set(v.url, "glow2", c2.glow)
						end
					end
				end
				val.enabled = true
				MOD.culling_ranges.visible_props[val] = true
			end
		end
	end
end

local function undo_tween(signal_tab)
	local changes = {[TWEEN_ACTION_MOVE] = {}, [TWEEN_ACTION_SCALE] = {}, [TWEEN_ACTION_ROTATE] = {}}
	for k, v in ipairs(signal_tab.tween.actions) do
		if not (v.type == TWEEN_ACTION_WAIT) then
			changes[v.type][v.part] = true
		end
	end
	for k, v in pairs(changes[TWEEN_ACTION_MOVE]) do
		go.set_position(signal_tab.transforms[k].position, signal_tab.transforms[k].url)
	end
	for k, v in pairs(changes[TWEEN_ACTION_SCALE]) do
		go.set(signal_tab.transforms[k].url, "scale", signal_tab.transforms[k].scale)
	end
	for k, v in pairs(changes[TWEEN_ACTION_ROTATE]) do
		go.set_rotation(signal_tab.transforms[k].rotation, signal_tab.transforms[k].url)
	end
end

local function apply_tween(signal_tab, time, full_reset)
	local changes = {[TWEEN_ACTION_MOVE] = {}, [TWEEN_ACTION_SCALE] = {}, [TWEEN_ACTION_ROTATE] = {}}
	if time - (signal_tab.time + signal_tab.tween.total_time) > 0 then
		for k, v in ipairs(signal_tab.tween.actions) do
			if not (v.type == TWEEN_ACTION_WAIT) then
				changes[v.type][v.part] = v.end_state
			end
		end
		for k, v in pairs(changes[TWEEN_ACTION_MOVE]) do
			go.set_position(v, signal_tab.transforms[k].url)
		end
		for k, v in pairs(changes[TWEEN_ACTION_SCALE]) do
			go.set(signal_tab.transforms[k].url, "scale", v)
		end
		for k, v in pairs(changes[TWEEN_ACTION_ROTATE]) do
			go.set_rotation(v, signal_tab.transforms[k].url)
		end
		signal_tab.used_up = true
		active_tweens[signal_tab] = nil
	elseif time - signal_tab.time > 0 then
		if full_reset then
			undo_tween(signal_tab)
		end
		for k, v in ipairs(signal_tab.tween.actions) do
			if not (v.type == TWEEN_ACTION_WAIT) then
				if time - (signal_tab.time + v.end_time) > 0 then
					changes[v.type][v.part] = v.end_state
				elseif time - (signal_tab.time + v.start_time) > 0 then
					local action_progress = (time - (signal_tab.time + v.start_time)) / v.duration
					if v.type == TWEEN_ACTION_ROTATE then
						changes[v.type][v.part] = vmath.slerp(action_progress, v.start_state, v.end_state)
					else
						changes[v.type][v.part] = vmath.lerp(action_progress, v.start_state, v.end_state)
					end
				else
					break
				end
			end
		end
		for k, v in pairs(changes[TWEEN_ACTION_MOVE]) do
			go.set_position(v, signal_tab.transforms[k].url)
		end
		for k, v in pairs(changes[TWEEN_ACTION_SCALE]) do
			go.set(signal_tab.transforms[k].url, "scale", v)
		end
		for k, v in pairs(changes[TWEEN_ACTION_ROTATE]) do
			go.set_rotation(v, signal_tab.transforms[k].url)
		end
	else
		undo_tween(signal_tab)
	end
end

local function get_beats(start, spb, beats_per_measure)
	MOD.seconds_per_beat = spb
	MOD.beat_start_time = start
	local bpm = beats_per_measure
	if bpm < 4 then
		bpm = 4 / (beats_per_measure / 4)
	end
	MOD.whiteout_delay = spb * bpm * 2
	MOD.whiteout_duration = spb * bpm * 2
	beat_duration = spb * 0.5
end

local count = 0
function update(self, dt)
	count = count + 1
	
	if MOD.viewer_active then
		local pitch = vmath.quat_rotation_x(math.rad(MOD.target_y))
		local yaw = vmath.quat_rotation_y(math.rad(MOD.target_x))
		local rot = yaw * pitch
		go.set_rotation(rot, MODEL_CAMERA)

		if MOD.tween_preview then
			if MOD.find_prop then
				MOD.find_prop = false
				if MOD.vacuum_preview then
					CAMERA_POSITION = go.get_world_position(preview_model[1].url) + vmath.rotate(rot, vmath.vector3(0, 0, 10))
				end
			else
				local move_vector = vmath.vector3(MOD.cam_target_x, 0, MOD.cam_target_z)
				CAMERA_POSITION = CAMERA_POSITION + vmath.rotate(rot, move_vector)
				CAMERA_POSITION.y = CAMERA_POSITION.y + MOD.cam_target_y
				if MOD.pov_lock and MOD.tween_preview then
					CAMERA_POSITION.x = G.clamp(CAMERA_POSITION.x, -2, 2)
					CAMERA_POSITION.y = G.clamp(CAMERA_POSITION.y, 0.5, 2.5)
					CAMERA_POSITION.z = G.clamp(CAMERA_POSITION.z, -2, 2)
				end
				go.set_position(CAMERA_POSITION, MODEL_CAMERA)
			end
			MOD.cam_target_x, MOD.cam_target_y, MOD.cam_target_z = 0, 0, 0
		else
			if MOD.find_prop then
				MOD.find_prop = false
				CAMERA_POSITION = go.get_world_position(preview_model[1].mesh)
			else
				local move_vector = vmath.vector3(MOD.cam_target_x, MOD.cam_target_y, 0)
				CAMERA_POSITION = CAMERA_POSITION + vmath.rotate(rot, move_vector)
			end
			go.set_position(CAMERA_POSITION, CAMERA_TARGET)
			MOD.cam_zoom = math.max(MOD.cam_zoom + MOD.cam_target_z, 0)
			local pos = vmath.rotate(rot, vmath.vector3(0, 0, MOD.cam_zoom))
			go.set_position(pos, MODEL_CAMERA)
			MOD.cam_target_x, MOD.cam_target_y, MOD.cam_target_z = 0, 0, 0
		end
		if MOD.tween_preview then
			local t = MOD.preview_start + MOD.total_time * MOD.scrubber_progress
			if MOD.vacuum_preview then
				for key, val in ipairs(MOD.vacuum_signal_tabs) do
					if next(val.transforms) then
						apply_tween(val, t)
					end
				end
				return
			end
			local z = t * 3
			if not MOD.stationary then
				if MOD.move_terrain then
					go.set(GROUND_GO, "position.z", -z)
					go.set("/player_capsule", "position.z", 0)
				else
					local pos_z = -z - go.get(GROUND_GO, "position.z")
					go.set("/player_capsule", "position.z", pos_z)
				end
			end
			if MOD.preview_start then
				if MOD.desync_check_start then
					local playtime = socket.gettime() - MOD.desync_check_start
					local delay = playtime - desync_check_playtime
					if delay > SET.max_desync then
						local time = desync_check_scrubber + (playtime / MOD.total_time)
						msg.post(".", hash("move_scrubber"), {time = time})
					end
					desync_check_playtime = desync_check_playtime + dt
				end

				for i = MOD.previous_colour or 1, #MEM.art_data.colour_list do
					local val = MEM.art_data.colour_list[i]
					if t < val.time then
						apply_colour_section(math.max(i - 1, 1), t)
						break
					end
				end

				local beats_active = true
				local start, spb, beats_per_measure = 0, 1, 4
				for key, val in ipairs(MEM.event_track) do
					if t < val.time then break end
					if val.type == NOBEAT_START then
						beats_active = false
					elseif val.type == NOBEAT_END then
						beats_active = true
					else
						start = val.time
						spb = val.spb
						beats_per_measure = val.beats_per_measure
					end
				end
				get_beats(start, spb, beats_per_measure)

				
				MOD.previous_colour = current_colour

				
				local beat_time = math.huge
				if beats_active then
					beat_time = (t - MOD.beat_start_time + beat_duration * 0.5) % MOD.seconds_per_beat
				end
				local whiteout_time = (t - MOD.beat_start_time) % MOD.whiteout_delay
				local beat_flash, whiteout_flash
				if whiteout_time <= MOD.whiteout_duration then
					whiteout_in_progress = true
					local whiteout_z = -3 * (t - whiteout_time)
					if MOD.stationary then
						whiteout_z = 0
					end
					whiteout_flash = whiteout_z - 128 * (whiteout_time / MOD.whiteout_duration)
				end
				if beat_time <= beat_duration then
					beat_in_progress = true
					beat_flash = 1 - math.abs(beat_time - beat_duration * 0.5) / (beat_duration * 0.5)
				end
				if beat_flash or whiteout_flash or whiteout_in_progress or beat_in_progress then
					if beat_flash then
						for key, val in pairs(MOD.culling_ranges.visible_slices) do
							go.set(msg.url(nil, key.model, "mesh"), "tint2.w", beat_flash)
						end
						for k, v in ipairs(beatcubes) do
							go.set(v.model_url, "flash.x", beat_flash)
						end
					elseif beat_in_progress then
						for key, val in pairs(MOD.culling_ranges.visible_slices) do
							go.set(msg.url(nil, key.model, "mesh"), "tint2.w", 0)
						end
						for k, v in ipairs(beatcubes) do
							go.set(v.model_url, "flash.x", 0)
						end
					end
					for key, val in pairs(MOD.culling_ranges.visible_props) do
						for k, v in ipairs(key.models) do
							if v.flash then
								if beat_flash then
									go.set(v.url, "flash.x", beat_flash)
								end
							elseif v.whiteout then
								if beat_flash then
									go.set(v.url, "flash.x", beat_flash)
								elseif beat_in_progress then
									go.set(v.url, "flash.x", 0)
								end
								if whiteout_flash then
									go.set(v.url, "flash.w", 1)
									go.set(v.url, "flash.z", whiteout_flash)
								elseif whiteout_in_progress then
									go.set(v.url, "flash.w", 0)
								end
							end
						end
					end
					if not whiteout_flash then
						whiteout_in_progress = false
					end
					if not beat_flash then
						beat_in_progress = false
					end
				end
				current_culling_range = G.clamp(math.floor((z + 6) / 16), 0, MOD.max_culling_range)
				if not (current_culling_range == previous_culling_range or MOD.stationary) then
					for key, val in pairs(MOD.culling_ranges.visible_slices) do
						if val and (not key.ranges[current_culling_range]) then
							msg.post(key.model, hash("disable"))
							key.enabled = false
							MOD.culling_ranges.visible_slices[key] = false
						end
					end
					for key, val in pairs(MOD.culling_ranges.visible_props) do
						if val and (not key.ranges[current_culling_range]) then
							for k, v in ipairs(key.models) do
								msg.post(v.mesh, hash("disable"))
							end
							key.enabled = false
							MOD.culling_ranges.visible_props[key] = false
						end
					end
					show_culling_range(self, current_culling_range)
					previous_culling_range = current_culling_range
				end

				
				for key, val in ipairs(MOD.culling_ranges[current_culling_range - 1].signals or {}) do
					if not (val.used_up or active_tweens[val]) then
						if t - val.time > 0 then
							if (t - (val.time + val.tween.total_time) < 0) or (t - (val.time + val.tween.total_time) > 0) then
								active_tweens[val] = true
							end
						end
					end
				end
				for key, val in ipairs(MOD.culling_ranges[current_culling_range].signals or {}) do
					if not (val.used_up or active_tweens[val]) then
						if t - val.time > 0 then
							if (t - (val.time + val.tween.total_time) < 0) or (t - (val.time + val.tween.total_time) > 0) then
								active_tweens[val] = true
							end
						end
					end
				end
				for key, val in pairs(active_tweens) do
					apply_tween(key, t)
				end
			end
		end
	end
end

local function delete_static()
	stop_flash()
	for key, val in ipairs(static_meshes) do
		go.delete(val.mesh)
		if val.buffer_resource then
			MOD.buffer_resource_released(val.buffer_resource)
		end
	end
	static_meshes = {}
	if MOD.culling_ranges then
		MOD.culling_ranges.visible_props = {}
		for key, val in pairs(MOD.culling_ranges) do
			for k, v in ipairs(val.props or {}) do
				v.enabled = nil
				v.models = nil
			end
		end
	end
end

local function delete_geo()
	for key, val in ipairs(geo_meshes) do
		MOD.buffer_resource_released(val.buffer_resource)
		go.delete(val.mesh)
	end
	for key, val in ipairs(chunk_meshes) do
		MOD.buffer_resource_released(val.buffer_resource)
		go.delete(val.mesh)
	end
	geo_meshes = {}
	chunk_meshes = {}
	if MOD.culling_ranges then
		MOD.culling_ranges.visible_slices = {}
		MOD.culling_ranges.visible_chunks = {}
		for key, val in pairs(MOD.culling_ranges) do
			for k, v in ipairs(val.slices or {}) do
				v.model = nil
				v.enabled = nil
			end
			for k, v in ipairs(val.chunks or {}) do
				v.model = nil
				v.enabled = nil
			end
		end
	end
end

local function delete_model(self)
	stop_flash()
	delete_static()
	delete_geo()
	for key, val in ipairs(created_transforms) do
		go.delete(val)
	end
	created_transforms = {}
	preview_model = {}
	preview_model_flash = {}
	preview_model_transforms = {}
end

local function reset_signals()
	active_tweens = {}
	for range, range_tab in pairs(MOD.culling_ranges) do
		if range_tab.signals then
			for key, val in ipairs(range_tab.signals) do
				val.used_up = false
				val.transforms = nil
			end
		end
	end
end

local function show_transforms()
	if SET.show_transform == 2 then
		for key, val in ipairs(created_transforms) do
			msg.post(msg.url(nil, val, "transform_model"), hash("enable"))
		end
	else
		for key, val in ipairs(created_transforms) do
			if (SET.show_transform == 1) and (MOD.visible_transform == key) then
				msg.post(msg.url(nil, val, "transform_model"), hash("enable"))
			else
				msg.post(msg.url(nil, val, "transform_model"), hash("disable"))
			end
		end
	end
end

local function show_model(self, model_index, no_flash, keep_camera)
	delete_model(self)
	timer.delay(0, false, function()
		local t = {position = vmath.vector3(0, 0, 0), rotation = vmath.quat(0, 0, 0, 1), scale = vmath.vector3(1), model_index = model_index}
		preview_model, preview_model_transforms = create_prop(self, t, nil, true)
		if MOD.vacuum_preview then
			for key, val in ipairs(MOD.vacuum_signal_tabs) do
				val.transforms = preview_model_transforms
			end
			stop_flash()
			no_flash = true
			reset_view(hash("preview"))
		end
		preview_model_flash = create_prop(self, t, true)
		if not (keep_camera or MOD.vacuum_preview) then
			reset_view(hash("model"))
		end
		if not no_flash then
			flash({1})
		end
		show_transforms()
	end)
end

local function apply_all_tweens()
	active_tweens = {}
	local t = MOD.preview_start + MOD.total_time * MOD.scrubber_progress
	for range, range_tab in pairs(MOD.culling_ranges) do
		if range_tab.signals then
			for key, val in ipairs(range_tab.signals) do
				val.used_up = false
				if val.transforms then
					apply_tween(val, t, true)
				end
				if (not val.used_up) and (t - val.time > 0) then
					if (t - (val.time + val.tween.total_time) < 0) or (t - (val.time + val.tween.total_time) > 0) then
						if val.transforms then
							active_tweens[val] = true
						end
					end
				end
			end
		end
	end
end

local function hide_fog()
	SET.hide_fog = not SET.hide_fog
	if SET.hide_fog then
		msg.post("/fog#fog", hash("disable"))
	else
		msg.post("/fog#fog", hash("enable"))
	end
	local t = MOD.preview_start + MOD.total_time * MOD.scrubber_progress
	for key, val in ipairs(MEM.art_data.colour_list) do
		if ((t >= val.time) and (not val.end_time or (t < val.end_time))) or (key == #MEM.art_data.colour_list) then
			MOD.previous_colour = nil
			apply_colour_section(key, t)
			break
		end
	end
end

local function hide_props()
	SET.hide_props = not SET.hide_props
	if SET.hide_props then
		for key in pairs(MOD.culling_ranges.visible_props) do
			for k, v in ipairs(key.models) do
				msg.post(v.url, hash("disable"))
			end
		end
	else
		for key in pairs(MOD.culling_ranges.visible_props) do
			for k, v in ipairs(key.models) do
				msg.post(v.url, hash("enable"))
			end
		end
	end
end

local function hide_geo()
	SET.hide_geo = SET.hide_geo + 1
	if SET.hide_geo > 3 then
		SET.hide_geo = 1
	end
	if SET.hide_geo == 1 then
		for key in pairs(MOD.culling_ranges.visible_slices) do
			msg.post(key.model, hash("enable"))
		end
	else
		for key in pairs(MOD.culling_ranges.visible_slices) do
			msg.post(key.model, hash("disable"))
		end
	end
	if SET.hide_geo == 2 then
		for key in pairs(MOD.culling_ranges.visible_chunks) do
			msg.post(key.model, hash("enable"))
		end
	else
		for key in pairs(MOD.culling_ranges.visible_chunks) do
			msg.post(key.model, hash("disable"))
		end
	end
end

local function create_beatcubes()
	for key, val in ipairs(beatcubes or {}) do
		go.delete(val.url)
	end
	beatcubes = {}

	local song_length = 0
	if MEM.level_data then
		if MEM.level_data.songLength then
			song_length = tonumber(MEM.level_data.songLength) or 0
		elseif MOD.culling_ranges then
			song_length = (MOD.max_culling_range - 3) * 16 / 3
		end
	end
	if song_length < 1 then song_length = 300 end

	local num = math.floor((song_length * 3) / 7) - 1
	local start = 0
	repeat
		local z, fac
		if num > 31 then
			fac = "#beatcubes_224"; z = 224
		elseif num > 15 then
			fac = "#beatcubes_112"; z = 112
		elseif num > 7 then
			fac = "#beatcubes_56"; z = 56
		elseif num > 3 then
			fac = "#beatcubes_28"; z = 28
		elseif num > 1 then
			fac = "#beatcubes_14"; z = 14
		elseif num > 0 then
			fac = "#beatcubes_7"; z = 7
		else
			break
		end
		local cube = factory.create(fac, vmath.vector3(0, 0, start + 9.5))
		start = start + z
		num = num - (z / 7)
		go.set_parent(cube, "/geo_base")
		table.insert(beatcubes, {url = cube, model_url = msg.url(nil, cube, "model")})
		msg.post(cube, hash("disable"))
	until num < 1
end

local function prepare_preview(self)
	if MOD.map_preview then
		tween_padding_start = 0
	else
		tween_padding_start = SET.tween_padding_start
	end
	active_tweens = {}
	if MEM.event_data.table then
		local first_tempo = MEM.event_data.table.tempoSections[1]
		get_beats(first_tempo.startSample / SET.sample_rate, first_tempo.samplesPerBeat / SET.sample_rate, first_tempo.beatsPerMeasure)
	else
		get_beats(0, 1, 4)
	end
	previous_culling_range, MOD.previous_colour = nil, nil

	reset_view(hash("preview"))
	if MOD.stationary and (not MOD.vacuum_preview) then
		apply_colour_section(1, 0)
		show_culling_range(self, 0)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("tween_preview") then
		msg.post(".", hash("enable"))
		MOD.viewer_active = true
		msg.post(".", hash("acquire_input_focus"))
		show_grid(self)
		msg.post("/fog#fog", hash("enable"))
		show_transforms()
	elseif message_id == hash("show_model_preview") then
		msg.post(".", hash("enable"))
		MOD.viewer_active = true
		MOD.previous_colour = nil
		apply_colour_section(1, 0)
		if message.model > 0 then
			show_model(self, message.model)
			apply_colours_model()
		else
			delete_model(self)
		end
		msg.post(".", hash("acquire_input_focus"))
		show_grid(self)
		show_transforms()
		msg.post("/fog#fog", hash("enable"))
	elseif message_id == hash("remove_model") then
		delete_model(self)
	elseif message_id == hash("change_material") then
		if message.part_index then
			local part_tab = MEM.art_data.table.propsDictionary[message.model_index].model_data.parts[message.part_index]
			local url = preview_model[message.part_index].url
			local mesh_props = set_material(self, url, part_tab.tab[part_tab.index])
			mesh_props.mesh = url
			preview_model[message.part_index] = mesh_props
		else
			for key, val in ipairs(MEM.art_data.table.propsDictionary[message.model_index].model_data.parts) do
				local url = preview_model[key].url
				local mesh_props = set_material(self, url, val.tab[val.index])
				mesh_props.mesh = url
				preview_model[key] = mesh_props
			end
		end
	elseif message_id == hash("update_model") then
		show_model(self, message.model, message.no_flash, message.keep_camera)
	elseif message_id == hash("show_part") then
		flash({message.selected_part})
	elseif message_id == hash("flash") then
		if MEM.art_data.temp_part_list then
			flash(MEM.art_data.temp_part_list)
			MEM.art_data.temp_part_list = nil
		end
	elseif message_id == hash("stop_flashing") then
		stop_flash()
	elseif message_id == hash("hide_context") then
		show_model(self, MOD.model_index)
		for key, val in pairs(MOD.culling_ranges) do
			for k, v in ipairs(val.slices or {}) do
				if v.enabled then
					local url = msg.url(nil, v.model, "mesh")
					v.enabled = false
					msg.post(url, hash("disable"))
				end
			end
			for k, v in ipairs(val.props or {}) do
				if v.enabled then
					for _k, _v in ipairs(v.models) do
						msg.post(_v.mesh, hash("disable"))
					end
				end
			end
		end
	elseif message_id == hash("playback_started") then
		desync_check_playtime = 0
		MOD.desync_check_start = socket.gettime()
		desync_check_scrubber = MOD.scrubber_progress
	elseif message_id == hash("move_geo") then
		go.set("/geo_base", "position.z", message.z)
		go.set("/static_prop_base", "position.z", message.z)
	elseif message_id == hash("scrubber_moved") then
		apply_all_tweens()
		if message.resume_afterwards then
			msg.post(".", hash("resume_playback"))
		end
	elseif message_id == hash("prepare_preview") then
		prepare_preview(self)
	elseif message_id == hash("create_beatcubes") then
		create_beatcubes()
	elseif message_id == hash("hide") then
		MOD.viewer_active = false
		MOD.is_dragged = false
		MOD.camera_is_dragged = false
		msg.post(".", hash("release_input_focus"))
		msg.post(".", hash("disable"))
		msg.post("/grid#grid", hash("disable"))
		msg.post("/player_capsule", hash("disable"))
		delete_model(self)
		msg.post("/fog#fog", hash("disable"))
	elseif message_id == hash("reset_tween") then
		delete_static()
		delete_geo()
		hide_beatcubes(true)
		reset_signals()
		previous_culling_range, MOD.previous_colour = nil, nil
	elseif message_id == hash("colours_changed") then
		if MOD.colour_override then
			MOD.previous_colour = nil
			override_colour()
		else
			local t = MOD.preview_start + MOD.total_time * MOD.scrubber_progress
			for key, val in ipairs(MEM.art_data.colour_list) do
				if ((t >= val.time) and (not val.end_time or (t < val.end_time))) or (key == #MEM.art_data.colour_list) then
					MOD.previous_colour = nil
					apply_colour_section(key, t)
					break
				end
			end
		end
	elseif message_id == hash("hide_fog") then
		hide_fog()
	elseif message_id == hash("hide_props") then
		hide_props()
	elseif message_id == hash("hide_geo") then
		hide_geo()
	elseif message_id == hash("hide_beatcubes") then
		hide_beatcubes()
	elseif message_id == hash("reset_view") then
		reset_view(message.mode)
	elseif message_id == hash("show_capsule") then
		msg.post("/player_capsule", hash("enable"))
	elseif message_id == hash("show_grid") then
		show_grid(self)
	elseif message_id == hash("show_transforms") then
		show_transforms()
	elseif message_id == hash("set_enemy_rotation") then
		go.set_rotation(message.rotation, "/enemy_model")
	end
end
