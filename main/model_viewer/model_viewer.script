local MEM = require "modules.memory"
local SET = require "modules.settings"
local G = require "modules.global"
local MOD = require "modules.models"
local COL = require "modules.colours"

local MODEL_CAMERA = "/model_camera"
local CAMERA_TARGET = "/camera_target"
local BASE_TRANSFORM = "/base_transform"
local PROP_OFFSET = "/prop_offset"
local GROUND_GO = "/ground"

go.property("prop_material", resource.material("/render/model.material"))
go.property("glow_material", resource.material("/render/glow.material"))
go.property("no_light_material", resource.material("/render/no_light.material"))
go.property("flash_material", resource.material("/render/flash.material"))
go.property("flash_inv", resource.material("/render/flash_inv.material"))

go.property("prop_inv", resource.material("/render/model_inv.material"))
go.property("glow_inv", resource.material("/render/glow_inv.material"))
go.property("no_light_inv", resource.material("/render/no_light_inv.material"))

go.property("glow_tex", resource.texture("/assets/gfx/white_pixel.png"))
go.property("prop_tex", resource.texture("/assets/gfx/textures/prop.png"))
go.property("cont_1_tex", resource.texture("/assets/gfx/textures/continental_1.png"))
go.property("cont_2_tex", resource.texture("/assets/gfx/textures/continental_2.png"))
go.property("shield_tex", resource.texture("/assets/gfx/textures/shielded.png"))

go.property("grid_tex_dots", resource.texture("/assets/gfx/textures/grid_dots.png"))
go.property("grid_tex", resource.texture("/assets/gfx/textures/grid.png"))
go.property("floor_tex", resource.texture("/assets/gfx/textures/default_floor.png"))

local created_meshes = {}
local created_transforms = {}
local geo_meshes = {}
local geo_collider_meshes = {}
local static_meshes = {}

local show_fog = true

local CAMERA_POSITION = vmath.vector3(0, 0, 0)

local function reset_view()
	MOD.is_dragged = false
	MOD.camera_is_dragged = false
	MOD.target_x = SET.default_camera_rotation
	MOD.target_y = -SET.default_camera_pitch
	MOD.cam_target_x = 0
	MOD.cam_target_y = 0
	MOD.cam_target_z = SET.default_camera_zoom
	CAMERA_POSITION = vmath.vector3(0, 0, 0)
end

local function show_grid(self)
	if SET.model_show_grid == 1 then
		go.set("/grid#grid", "texture0", self.floor_tex)
		go.set("/grid#grid", "tint", COL.get_current("main"))
		msg.post("/grid#grid", hash("enable"))
	elseif SET.model_show_grid == 2 then
		if SET.model_grid_dots then
			go.set("/grid#grid", "texture0", self.grid_tex_dots)
		else
			go.set("/grid#grid", "texture0", self.grid_tex)
		end
		go.set("/grid#grid", "tint", vmath.vector4(1, 1, 1, 1))
		msg.post("/grid#grid", hash("enable"))
	else
		msg.post("/grid#grid", hash("disable"))
	end
end

function init(self)
	msg.post(".", hash("disable"))
	go.set("/model_camera#background", "tint", COL.get_current("fog"))
	msg.post("/model_camera#background", hash("disable"))
	msg.post("/grid#grid", hash("disable"))
	reset_view()
	--show_grid(self)
end

local tex_glow = hash("glow")
local tex_prop = hash("prop")
local tex_shaded = hash("shaded")
local tex_cont_1 = hash("cont_1")
local tex_cont_2 = hash("cont_2")
local tex_ped = hash("ped")
local tex_shield = hash("shield")
local tex_funky = hash("funky")

local flash_timer, flash_on, flash_off, flash_active
local flash_list = {}
function flash_off()
	if SET.mesh_flash_frequency > 0 then
		flash_active = false
		for key, val in pairs(flash_list) do
			go.set(val.url, "tint", val.tint)
			go.set(val.url, "texture0", val.tex)
			go.set(val.url, "material", val.mat)
		end
		if flash_timer then
			timer.cancel(flash_timer)
		end
		flash_timer = timer.delay(SET.mesh_flash_frequency, false, flash_on)
	end
end

function flash_on()
	if flash_timer then
		timer.cancel(flash_timer)
	end
	if SET.mesh_flash_time == 0 then return end
	flash_active = true
	for key, val in pairs(flash_list) do
		go.set(val.url, "tint", val.flash_tint)
		go.set(val.url, "texture0", val.flash_tex)
		go.set(val.url, "material", val.flash_mat)
	end
	flash_timer = timer.delay(SET.mesh_flash_time, false, flash_off)
end

local function stop_flash(self)
	if flash_timer then
		timer.cancel(flash_timer)
		flash_timer = nil
	end
	flash_active = false
	for key, val in pairs(flash_list) do
		go.set(val.url, "tint", val.tint)
		go.set(val.url, "texture0", val.tex)
		go.set(val.url, "material", val.mat)
	end
	flash_list = {}
end

local function flash(self, list)
	stop_flash(self)
	for key, val in ipairs(list) do
		local model_url = msg.url(nil, created_meshes[val].mesh, "mesh")
		local tint = go.get(model_url, "tint")
		local tex = go.get(model_url, "texture0")
		local mat = go.get(model_url, "material")
		local flash_material = {[true] = self.flash_inv, [false] = self.flash_material}
		flash_list[val] = {
			url = model_url,
			tint = tint,
			tex = tex,
			mat = mat,
			flash_tint = SET.mesh_flash_colour,
			flash_mat = flash_material[created_meshes[val].invert],
			flash_tex = self.glow_tex
		}
	end
	if #list > 0 then
		flash_on()
	end
end


local function set_material(self, part_index, model_index, flip, static)
	local model_url, invert
	if static then
		model_url = msg.url(nil, static_meshes[part_index].mesh, "mesh")
		invert = static_meshes[part_index].invert
	else
		model_url = msg.url(nil, created_meshes[part_index].mesh, "mesh")
		invert = created_meshes[part_index].invert
	end
	if MOD.inverted then
		invert = not invert
	end
	if flip then
		invert = not invert
	end
	local part_tab = MEM.art_data.table.propsDictionary[model_index].model_data.parts[part_index]
	local mat = part_tab.tab[part_tab.index]
	local mat_list = {
		[true] = {glow = self.glow_inv, prop = self.prop_inv, nl = self.no_light_inv, flash = self.flash_inv},
		[false] = {glow = self.glow_material, prop = self.prop_material, nl = self.no_light_material, flash = self.flash_material}
	}
	local new_material, new_texture, new_tint
	if not COL.materials[mat] then
		new_material = mat_list[invert].glow
		new_texture = self.glow_tex
	elseif COL.materials[mat].texture == tex_glow then
		new_material = mat_list[invert].glow
		new_texture = self.glow_tex
	elseif COL.materials[mat].texture == tex_shield then
		new_material = mat_list[invert].nl
		new_texture = self.shield_tex
	elseif COL.materials[mat].texture == tex_cont_1 then
		new_material = mat_list[invert].prop
		new_texture = self.cont_1_tex
	elseif COL.materials[mat].texture == tex_cont_2 then
		new_material = mat_list[invert].prop
		new_texture = self.cont_2_tex
	elseif COL.materials[mat].texture == tex_shaded then
		new_material = mat_list[invert].prop
		new_texture = self.glow_tex
	else
		new_material = mat_list[invert].prop
		new_texture = self.prop_tex
	end
	if COL.materials[mat] then
		new_tint = COL.materials[mat].tint()
	else
		new_tint = vmath.vector4(1, 0, 1, 1)
	end
	if flash_list[part_index] then
		flash_list[part_index].tint = new_tint
		flash_list[part_index].tex = new_texture
		flash_list[part_index].mat = new_material
		flash_list[part_index].flash_mat = mat_list[invert].flash
		if flash_active then
			go.set(model_url, "material", mat_list[invert].flash)
		else
			go.set(model_url, "tint", new_tint)
			go.set(model_url, "texture0", new_texture)
			go.set(model_url, "material", new_material)
		end
	else
		go.set(model_url, "tint", new_tint)
		go.set(model_url, "texture0", new_texture)
		go.set(model_url, "material", new_material)
	end
end

local function reset_tween(self)
	go.set(GROUND_GO, "position.z", 0)
	if not MOD.inverted then
		MOD.inverted = false
		for i = 1, #created_meshes do
			set_material(self, i, MOD.model_index)
		end
	end
	for key, val in pairs(MOD.tweenable_transforms) do
		if val.used then
			go.set_position(val.transform_tab.position, val.url)
			go.set(val.url, "scale", val.transform_tab.scale)
			go.set_rotation(val.transform_tab.rotation, val.url)
		end
	end
end

function update(self, dt)
	if MOD.viewer_active then
		local pitch = vmath.quat_rotation_x(math.rad(MOD.target_y))
		local yaw = vmath.quat_rotation_y(math.rad(MOD.target_x))
		local rot = yaw * pitch
		go.set_rotation(rot, MODEL_CAMERA)
		if MOD.pov_lock and MOD.tween_preview then
			go.set_position(vmath.vector3(0, 0, 0), CAMERA_TARGET)
			go.set_position(vmath.vector3(0, 1.75, 0), MODEL_CAMERA)
		else
			if MOD.find_prop then
				MOD.find_prop = false
				CAMERA_POSITION = go.get_world_position(created_meshes[1].mesh)
			else
				local move_vector = vmath.vector3(MOD.cam_target_x, MOD.cam_target_y, 0)
				CAMERA_POSITION = CAMERA_POSITION + vmath.rotate(rot, move_vector)
			end
			go.set_position(CAMERA_POSITION, CAMERA_TARGET)
			local pos = vmath.rotate(rot, vmath.vector3(0, 0, MOD.cam_target_z))
			go.set_position(pos, MODEL_CAMERA)
		end
		MOD.cam_target_x, MOD.cam_target_y = 0, 0
		if MOD.tween_preview then
			local scale = go.get_scale(PROP_OFFSET)
			local inverted = scale.x * scale.y * scale.z * -1 > 0
			if not (inverted == MOD.inverted) then
				MOD.inverted = inverted
				for i = 1, #created_meshes do
					set_material(self, i, MOD.model_index)
				end
			end

			for key, val in pairs(MOD.tweenable_transforms) do
				if val.used then
					val.position = vmath.vector3(val.transform_tab.position)
					val.rotation = vmath.quat(val.transform_tab.rotation)
					val.scale = vmath.vector3(val.transform_tab.scale)
				end
			end
			
			local current_time = MOD.total_time * MOD.scrubber_progress
			for tween_index, v in ipairs(MOD.tween_table) do
				local action_end_time = v.time_offset
				for key, val in ipairs(v) do
					action_end_time = action_end_time + val.time
					if current_time >= action_end_time then
						if val.type == "T" then
							MOD.tweenable_transforms[val.part].position = vmath.vector3(val.end_state.x, val.end_state.y, val.end_state.z)
						elseif val.type == "R" then
							MOD.tweenable_transforms[val.part].rotation = G.euler_to_quat(vmath.vector3(val.end_state.x, val.end_state.y, val.end_state.z))
						elseif val.type == "S" then
							MOD.tweenable_transforms[val.part].scale = vmath.vector3(val.end_state.x, val.end_state.y, val.end_state.z)
						end
					else
						local action_start = action_end_time - val.time
						local action_progress = (current_time - action_start) / val.time
						if not (action_progress == action_progress) then
							action_progress = 0		-- this shouldn't be necessary, but keeping it to be safe
						end
						local function get_state()
							local start_state = vmath.vector3(val.start_state.x, val.start_state.y, val.start_state.z)
							local end_state = vmath.vector3(val.end_state.x, val.end_state.y, val.end_state.z)
							return vmath.lerp(action_progress, start_state, end_state)
						end
						if val.type == "T" then
							MOD.tweenable_transforms[val.part].position = get_state()
						elseif val.type == "R" then
							local start_quat = G.euler_to_quat(val.start_state)
							local end_quat = G.euler_to_quat(val.end_state)
							MOD.tweenable_transforms[val.part].rotation = vmath.slerp(action_progress, start_quat, end_quat)
						elseif val.type == "S" then
							MOD.tweenable_transforms[val.part].scale = get_state()
						end
						break
					end
				end
			end

			for key, val in pairs(MOD.tweenable_transforms) do
				local sc
				if val.used then
					go.set_position(val.position, val.url)
					sc = vmath.vector3(val.scale.x, val.scale.y, val.scale.z)
					go.set(val.url, "scale", sc)
					go.set_rotation(val.rotation, val.url)
					val.flip = sc.x * sc.y * sc.z < 0
				end
			end
			for key, val in ipairs(created_meshes) do
				local inv = 1
				for k, v in ipairs(val.check_scale) do
					local sc = MOD.tweenable_transforms[v].scale
					inv = inv * sc.x * sc.y * sc.z * MOD.tweenable_transforms[v].base_inv
				end
				set_material(self, key, MOD.model_index, inv < 0)
			end
			
			if MOD.move_terrain then
				go.set(GROUND_GO, "position.z", current_time * 3)
			else
				go.set(GROUND_GO, "position.z", 0)
			end
		end
	end
end


local function delete_model(self)
	stop_flash(self)
	for key, val in ipairs(created_meshes) do
		go.delete(val.mesh)
		MOD.mesh_deleted(val.buffer)
	end
	for key, val in ipairs(created_transforms) do
		go.delete(val)
	end
	created_meshes, created_transforms = {}, {}
end

local function adjust_transform_positions()
	go.set_position(MOD.offset_position, PROP_OFFSET)
	go.set(PROP_OFFSET, "position.z", -MOD.offset_position.z)
	go.set(PROP_OFFSET, "scale", MOD.offset_scale)
	go.set_rotation(MOD.offset_rotation, PROP_OFFSET)
end

local function get_parent(transform_index, transform_list)
	if transform_index < 2 then return false end
	local parent_tab = transform_list[transform_index].parent_tab
	for i = transform_index - 1, 1, -1 do
		if transform_list[i] == parent_tab then
			return i
		end
	end
end

local function show_transforms()
	if SET.show_transform == 2 then
		for key, val in ipairs(created_transforms) do
			msg.post(msg.url(nil, val, "transform_model"), hash("enable"))
		end
	else
		for key, val in ipairs(created_transforms) do
			if (SET.show_transform == 1) and (MOD.visible_transform == key) then
				msg.post(msg.url(nil, val, "transform_model"), hash("enable"))
			else
				msg.post(msg.url(nil, val, "transform_model"), hash("disable"))
			end
		end
	end
end

local function create_mesh(mesh_tab, parent, invert, transform_index, mesh_type)
	local new_mesh = factory.create("#create_mesh")
	msg.post(new_mesh, hash("disable"))
	go.set_parent(new_mesh, parent)
	local _url = msg.url(nil, new_mesh, "mesh")
	go.set(_url, "vertices", mesh_tab.buffer_resource)

	MOD.mesh_created(mesh_tab.buffer_resource)
	
	if mesh_type == "geo" then
		table.insert(geo_meshes, {mesh = new_mesh})
	elseif mesh_type == "collider" then
		table.insert(geo_collider_meshes, {mesh = new_mesh})
	elseif mesh_type == "static" then
		table.insert(static_meshes, {mesh = new_mesh, invert = invert})
	else
		table.insert(created_meshes, {mesh = new_mesh, invert = invert, parent_transform = transform_index, buffer = mesh_tab.buffer_resource})
	end
end

local function delete_geo()
	for key, val in ipairs(geo_meshes) do
		if not val.empty then
			go.delete(val.mesh)
		end
	end
	geo_meshes = {}
end

local function show_geo(self)
	delete_geo()
	if true then return end
	for key, val in ipairs(MEM.geo_data.slices) do
		if not val.empty then
			create_mesh(val, nil, false, 1, "geo")
			local new_mesh = geo_meshes[#geo_meshes].mesh
			go.set_parent(new_mesh, "/geo_base")
			go.set_position(vmath.vector3(0, 0, 16.1 * val.id), new_mesh)
			local model_url = msg.url(nil, new_mesh, "mesh")
			go.set(model_url, "tint", COL.geo())
			go.set(model_url, "texture0", self.prop_tex)
			go.set(model_url, "material", self.prop_material)
			msg.post(new_mesh, hash("enable"))
		end
	end
	if true then return end
	for key, val in ipairs(MEM.geo_data.chunks) do
		if not val.empty then
			create_mesh(val, nil, false, 1, "collider")
			local new_mesh = geo_collider_meshes[#geo_collider_meshes].mesh
			go.set_parent(new_mesh, "/geo_base")
			go.set_position(vmath.vector3(16 * val.id[1], 16 * val.id[2], 16 * val.id[3]), new_mesh)
			local model_url = msg.url(nil, new_mesh, "mesh")
			go.set(model_url, "tint", COL.geo())
			go.set(model_url, "texture0", self.prop_tex)
			go.set(model_url, "material", self.prop_material)
			msg.post(new_mesh, hash("enable"))
		end
	end
end

local static_prop_transforms = {}


local function create_static_models(self)
	for _k, _v in ipairs(MEM.art_data.prop_list) do
		local model_index
		for key, val in ipairs(MEM.art_data.table.propsDictionary) do
			if val.key == _v.name then
				model_index = key
				break
			end
		end
		if model_index then
			local new_base = factory.create("#create_transform_invisible")
			table.insert(static_prop_transforms, new_base)
			go.set_parent(new_base, "/static_prop_base")
			
			local mesh_count = 0
			local transform_list = MEM.art_data.table.propsDictionary[model_index].model_data.transform_list
			local meta_table = {}
			for key, val in ipairs(transform_list) do
				local invert = false
				local new_transform = factory.create("#create_transform_invisible")
				table.insert(static_prop_transforms, new_transform)
				if val.parent_tab then
					go.set_parent(new_transform, meta_table[val.parent_tab])
					go.set_position(val.position, new_transform)
				else
					go.set_parent(new_transform, new_base)
				end
				local sc = val.scale.x * val.scale.y * val.scale.z
				local parent = get_parent(key, transform_list)
				if parent then
					local safety = 10000
					repeat
						sc = sc * transform_list[parent].scale.x * transform_list[parent].scale.y * transform_list[parent].scale.z
						parent = get_parent(parent, transform_list)
						safety = safety - 1
					until (not parent) or (safety < 0)
				end
				if sc < 0 then
					invert = true
				end
				go.set_rotation(val.rotation, new_transform)
				go.set(new_transform, "scale", val.scale)
				meta_table[val] = new_transform
				if val.meshes then
					for k, v in ipairs(val.meshes) do
						mesh_count = mesh_count + 1
						create_mesh(v, new_transform, invert, key, "static")
						set_material(self, mesh_count, model_index, nil, true)
					end
				end
			end
			go.set_position(_v.position, new_base)
			--go.set(new_base, "position.z", -_v.position.z)
			go.set(new_base, "scale", _v.scale)
			go.set_rotation(_v.rotation, new_base)
		end
	end
	for key, val in ipairs(static_meshes) do
		msg.post(val.mesh, hash("enable"))
	end
end

local function show_model(self, model_index)
	delete_model(self)
	MOD.tweenable_transforms = {}
	local mesh_count = 0
	local transform_list = MEM.art_data.table.propsDictionary[model_index].model_data.transform_list
	for key, val in ipairs(transform_list) do
		local invert = false
		local new_transform = factory.create("#create_transform")
		table.insert(created_transforms, new_transform)
		if val.parent_tab then
			go.set_parent(new_transform, val.parent_tab.transform_go)
			go.set_position(val.position, new_transform)
		else
			go.set_parent(new_transform, BASE_TRANSFORM)
		end
		local sc = val.scale.x * val.scale.y * val.scale.z
		local parent = get_parent(key, transform_list)
		if parent then
			local safety = 10000
			repeat
				sc = sc * transform_list[parent].scale.x * transform_list[parent].scale.y * transform_list[parent].scale.z
				parent = get_parent(parent, transform_list)
				safety = safety - 1
			until (not parent) or (safety < 0)
		end
		if sc < 0 then
			invert = true
		end
		go.set_rotation(val.rotation, new_transform)
		go.set(new_transform, "scale", val.scale)
		val.transform_go = new_transform
		if val.name then
			MOD.tweenable_transforms[val.name] = MOD.tweenable_transforms[val.name] or {
				url = new_transform,
				position = vmath.vector3(val.position),
				rotation = vmath.quat(val.rotation),
				scale = vmath.vector3(val.scale),
				used = false,
				transform_tab = val
			}
		end
		if val.meshes then
			for k, v in ipairs(val.meshes) do
				mesh_count = mesh_count + 1
				create_mesh(v, new_transform, invert, key, "model")
				set_material(self, mesh_count, model_index)
			end
		end
	end
	adjust_transform_positions()
	for key, val in ipairs(created_meshes) do
		msg.post(val.mesh, hash("enable"))
	end
	show_transforms()
end

function on_message(self, message_id, message, sender)
	if message_id == hash("show") or message_id == hash("tween_preview") then
		msg.post(".", hash("enable"))
		MOD.viewer_active = true
		if not message.model then
			for key, val in ipairs(created_meshes) do
				msg.post(val.mesh, hash("enable"))
			end
			for key, val in ipairs(created_transforms) do
				msg.post(val, hash("enable"))
			end
			if not MOD.tween_preview then
				flash(self, {message.selected_part})
			end
		elseif message.model > 0 then
			show_model(self, message.model)
			if created_meshes[message.selected_part] then
				flash(self, {message.selected_part})
			end
		elseif message.model == 0 then
			delete_model(self)
		end
		msg.post(".", hash("acquire_input_focus"))
		--msg.post("/grid#grid", hash("enable"))
		show_grid(self)
		msg.post("/model_camera#background", hash("enable"))
		show_transforms()
	elseif message_id == hash("geo_preview") then
		msg.post(".", hash("enable"))
		MOD.viewer_active = true
		msg.post(".", hash("acquire_input_focus"))
		--msg.post("/grid#grid", hash("enable"))
		show_geo(self)
		show_grid(self)
		msg.post("/model_camera#background", hash("enable"))
	elseif message_id == hash("move_geo") then
		show_geo(self)
		go.set("/geo_base", "position.z", message.z)
		--create_static_models(self)
		go.set("/static_prop_base", "position.z", message.z)
	elseif message_id == hash("prepare_tweens") then
		for key, val in pairs(MOD.tweenable_transforms) do
			val.used = false
		end
		for key, val in ipairs(MOD.tween_table) do
			for k, v in ipairs(val) do
				if v.part and MOD.tweenable_transforms[v.part] then
					MOD.tweenable_transforms[v.part].used = true
					local sc = MOD.tweenable_transforms[v.part].scale
					if sc.x * sc.y * sc.z > 0 then
						sc = 1
					else
						sc = -1
					end
					MOD.tweenable_transforms[v.part].base_inv = sc
				end
			end
		end
		local transform_list = MEM.art_data.table.propsDictionary[MOD.model_index].model_data.transform_list
		for key, val in ipairs(created_meshes) do
			val.check_scale = {}
			local parent = val.parent_transform
			local safety = 10000
			repeat
				if parent then
					local right_one = MOD.tweenable_transforms[transform_list[parent].name].url == transform_list[parent].transform_go
					if right_one and MOD.tweenable_transforms[transform_list[parent].name].used then
						table.insert(val.check_scale, transform_list[parent].name)
					end
				end
				parent = get_parent(parent, transform_list)
				safety = safety - 1
			until (not parent) or (safety < 0)
		end
	elseif message_id == hash("offsets_changed") then
		adjust_transform_positions()
	elseif message_id == hash("update_model") then
		show_model(self, message.model)
		if not message.no_flash then
			flash(self, {1})
		end
	elseif message_id == hash("show_part") then
		flash(self, {message.selected_part})
	elseif message_id == hash("flash") then
		if MEM.art_data.temp_part_list then
			flash(self, MEM.art_data.temp_part_list)
			MEM.art_data.temp_part_list = nil
		end
	elseif message_id == hash("stop_flashing") then
		stop_flash(self)
	elseif message_id == hash("hide") then
		MOD.viewer_active = false
		MOD.is_dragged = false
		MOD.camera_is_dragged = false
		msg.post(".", hash("release_input_focus"))
		msg.post(".", hash("disable"))
		msg.post("/grid#grid", hash("disable"))
		for key, val in ipairs(created_meshes) do
			msg.post(val.mesh, hash("disable"))
		end
		for key, val in ipairs(created_transforms) do
			msg.post(val, hash("disable"))
		end
		stop_flash(self)
		msg.post("/model_camera#background", hash("disable"))
	elseif message_id == hash("reset_tween") then
		reset_tween(self)
	elseif message_id == hash("remove_model") then
		delete_model(self)
	elseif message_id == hash("colours_changed") then
		if show_fog then
			go.set("/model_camera#background", "tint", COL.get_current("fog"))
		end
		if SET.model_show_grid == 1 then
			go.set("/grid#grid", "tint", COL.get_current("main"))
		end
	elseif message_id == hash("change_material") then
		if message.part_index then
			set_material(self, message.part_index, message.model_index)
		else
			for key, val in ipairs(created_meshes) do
				set_material(self, key, message.model_index)
			end
		end
	elseif message_id == hash("switch_background") then
		show_fog = not show_fog
		if show_fog then
			go.set("/model_camera#background", "tint", COL.get_current("fog"))
		else
			go.set("/model_camera#background", "tint", vmath.vector4(0))
		end
	elseif message_id == hash("reset_view") then
		reset_view()
	elseif message_id == hash("show_grid") then
		SET.model_show_grid = SET.model_show_grid + 1
		if SET.model_show_grid > 3 then
			SET.model_show_grid = 1
		end
		show_grid(self)
	elseif message_id == hash("show_transforms") then
		show_transforms()
	elseif message_id == hash("rotate_view") then
		go.set_position(vmath.vector3(0, -1.3, 0), CAMERA_TARGET)
		go.set_position(vmath.vector3(0, 1.7, 10), MODEL_CAMERA)
		go.set_rotation(vmath.quat(0, 0, 0, 1), MODEL_CAMERA)
	elseif message_id == hash("set_enemy_rotation") then
		go.set_rotation(message.rotation, "/enemy_model")
	end
end
