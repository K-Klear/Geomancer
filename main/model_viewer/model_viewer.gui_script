local MEM = require "modules.memory"
local MOD = require "modules.models"
local SET = require "modules.settings"
local UI = require "modules.ui"
local COL = require "modules.colours"
local G = require "modules.global"
local SND = require "modules.sound"
local DIALOG = UI.DIALOG

local bounding_node, bounding_node_preview, bounding_node_transform, aux_node, button_box, playback_box
local close_button, timeline, scrubber, time_display, selected_timeline
local get_current_transform, previous_transform_name
local current_bounding_node
local colour_unselected_timeline = vmath.vector4(0.6, 0.6, 0.6, 1)

local move_scrubber
local mouse_wheel_scroll_target = 0

local TAB_NAME = "model_viewer"

local SET_MODEL_VIEWPORT = hash("set_model_viewport")
local GET_MODEL_VIEWPORT = hash("get_model_viewport")

local POSITION_MIN = 10
local POSITION_MAX = 1180
local BUTTON_BOX_POSITION = vmath.vector3(850, 56, 0)
local BUTTON_BOX_POSITION_PREVIEW = vmath.vector3(1280.0, 53, 0)
local BUTTON_BOX_SIZE = vmath.vector3(275.0, 50, 0)
local BUTTON_BOX_SIZE_PREVIEW = vmath.vector3(350, 322, 0)

local ACTIVE_BUTTON_COLOUR = vmath.vector4(1, 1, 0.5, 1)

MOD.offset_position = vmath.vector3(0, 0, 0)
MOD.offset_rotation = vmath.quat(0, 0, 0, 1)
MOD.offset_scale = vmath.vector3(1, 1, 1)
MOD.offset_euler = vmath.vector3(0, 0, 0)

local function set_button_colours()
	gui.set_color(gui.get_node("button_colour/main"), COL.get_current("main"))
	gui.set_color(gui.get_node("button_colour/fog"), COL.get_current("fog"))
	gui.set_color(gui.get_node("button_colour/glow"), COL.get_current("glow"))
	gui.set_color(gui.get_node("button_colour/enemy"), COL.get_current("enemy"))
end

local function update_offset_fields()
	local xyz = {"x", "y", "z"}
	for key, val in pairs(xyz) do
		gui.set_text(gui.get_node("position_"..val.."/text"), G.round(MOD.offset_position[val], 1))
		gui.set_text(gui.get_node("rotation_"..val.."/text"), G.round(MOD.offset_euler[val], 1))
		gui.set_text(gui.get_node("scale_"..val.."/text"), G.round(MOD.offset_scale[val], 2))
	end
	msg.post(".", hash("offsets_changed"))
end

local function get_viewport()
	local pos_1, pos_2
	pos_1 = gui.get_screen_position(current_bounding_node)
	pos_2 = gui.get_screen_position(aux_node)
	local w = pos_2.x - pos_1.x
	local h = pos_1.y - pos_2.y
	local ar = w / h
	camera.set_aspect_ratio("main:/model_camera#camera", ar)
	msg.post("@render:", SET_MODEL_VIEWPORT, {x = pos_1.x, y = pos_2.y, w = w, h = h})
end

local function change_bounds(node)
	gui.set_enabled(bounding_node, bounding_node == node)
	gui.set_enabled(bounding_node_preview, bounding_node_preview == node)
	gui.set_enabled(bounding_node_transform, bounding_node_transform == node)
	current_bounding_node = node
	local pos = gui.get_position(node)
	local size = gui.get_size(node) * gui.get(node, "scale.x")
	pos.x = pos.x + size.x; pos.y = pos.y - size.y
	gui.set_position(aux_node, pos)
	get_viewport()
end

local function set_transform_button()
	local transfrom_pics = {[0] = "button_transform_none", [1] = "button_transform_one", [2] = "button_transform_all"}
	if not SET.show_single_transform then transfrom_pics[1] = transfrom_pics[0] end
	gui.play_flipbook(gui.get_node("show_transforms/text"), transfrom_pics[SET.show_transform])
	msg.post(".", hash("show_transforms"))
end

local function set_hide_grid(change)
	if change then
		SET.model_show_grid = SET.model_show_grid + 1
		if SET.model_show_grid > 3 then
			SET.model_show_grid = 1
		end
	end
	if SET.model_show_grid == 3 then
		gui.play_flipbook(gui.get_node("hide_grid/text"), "button_hide_grid")
	elseif SET.model_show_grid == 1 then
		gui.play_flipbook(gui.get_node("hide_grid/text"), "button_show_grid")
	else
		gui.play_flipbook(gui.get_node("hide_grid/text"), "button_show_grid_normal")
	end
end

function init(self)
	MOD.map_preview = false
	update_offset_fields()
	set_transform_button()
	set_hide_grid()
	bounding_node = gui.get_node("model_viewer")
	bounding_node_preview = gui.get_node("model_viewer_preview")
	bounding_node_transform = gui.get_node("model_viewer_transform")
	aux_node = gui.new_box_node(vmath.vector3(0), vmath.vector3(1))
	gui.set_pivot(aux_node, gui.PIVOT_NW)
	gui.set_visible(aux_node, false)
	gui.set_enabled(gui.get_node("visibility_box"), false)
	gui.set_enabled(gui.get_node("visibility_box_buttons"), false)
	change_bounds(bounding_node)
	button_box = gui.get_node("button_box")
	playback_box = gui.get_node("playback_box")
	close_button = gui.get_node("close_preview/button_white")
	gui.set_position(button_box, BUTTON_BOX_POSITION)
	gui.set_size(button_box, BUTTON_BOX_SIZE)
	timeline = gui.get_node("timeline_box")
	scrubber = gui.get_node("scrubber")
	time_display = gui.get_node("label_time")
	gui.set_enabled(timeline, false)
	gui.set_visible(timeline, false)
	gui.set_enabled(playback_box, false)
	gui.set_enabled(close_button, false)
	gui.set_enabled(time_display, false)
	gui.set_enabled(gui.get_node("offset_box"), false)
	gui.set_render_order(1)
	UI.load_template({"reset_view", "show_transforms"}, TAB_NAME)
	set_button_colours()
	--msg.post("#", hash("disable"))
end

local action_bars, timelines = {}, {}

local function percent_to_position(percent)
	return (percent * POSITION_MAX) + POSITION_MIN
end

local function delete_timeline()
	for key, val in ipairs(timelines) do
		gui.delete_node(val)
	end
	timelines = {}
	for key, val in ipairs(action_bars) do
		for k, v in ipairs(val) do
			gui.delete_node(v.bar)
			gui.delete_node(v.ending)
		end
		gui.delete_node(val[0])
	end
	action_bars = {}
end

local function update_view(update_scubber)
	if update_scubber then
		local min_x = gui.get_screen_position(gui.get_node("min")).x
		local max_x = gui.get_screen_position(gui.get_node("max")).x
		local pos = gui.get_screen_position(scrubber)
		MOD.scrubber_progress = (pos.x - min_x) / (max_x - min_x)
		get_current_transform()
	end
	local time_to_display = (MOD.total_time * MOD.scrubber_progress) - SET.tween_padding_start
	if selected_timeline and MOD.tween_table and MOD.tween_table[selected_timeline].time_offset then
		time_to_display = time_to_display - MOD.tween_table[selected_timeline].time_offset
	end
	gui.set_text(time_display, G.round(time_to_display, 3))
end


local function select_timeline(selection)
	if not (selection == selected_timeline) then
		gui.set_color(timelines[selected_timeline], colour_unselected_timeline)
		gui.set_color(timelines[selection], vmath.vector4(1, 1, 1, 1))
		selected_timeline = selection
		get_current_transform()
		update_view()
	end
end

local function create_tween_sections()
	MOD.total_time = 0
	delete_timeline()
	for tween_index, tween_table in ipairs(MOD.tween_table) do
		tween_table.time_offset = 0
		if MOD.prop_data.lowest_z then
			tween_table.time_offset = ((MOD.prop_data.signal_z[tween_index] or MOD.prop_data.lowest_z) - MOD.prop_data.lowest_z) / 3
		end
		action_bars[tween_index] = {}
		local new_timeline = gui.clone(gui.get_node("timeline"))
		gui.set(new_timeline, "position.y", SET.tween_timeline_bar_height * (tween_index - 0.5))
		gui.set(new_timeline, "size.y", SET.tween_timeline_bar_height)
		gui.set_enabled(new_timeline, true)
		table.insert(timelines, new_timeline)
		if not (tween_index == selected_timeline) then
			gui.set_color(new_timeline, colour_unselected_timeline)
		end
		
		local tween_time = tween_table.time_offset + SET.tween_padding_start
		for key, val in ipairs(tween_table) do
			if val.type == "X" then

			else
				local function add_bar(time)
					local new_bar = gui.clone(gui.get_node("action_bar"))
					local new_bar_end = gui.clone(gui.get_node("action_end"))
					gui.set_parent(new_bar, new_timeline)
					gui.set_parent(new_bar_end, new_timeline)
					gui.set_enabled(new_bar, true)
					gui.set_enabled(new_bar_end, true)
					if val.type == "T" then
						gui.set_color(new_bar, SET.colour_tween_move)
					elseif val.type == "R" then
						gui.set_color(new_bar, SET.colour_tween_rotate)
					elseif val.type == "S" then
						gui.set_color(new_bar, SET.colour_tween_scale)
					elseif val.type == "W" then
						gui.set_color(new_bar, SET.colour_tween_wait)
					else
						gui.set_color(new_bar, vmath.vector4(0.5, 0, 0, 1))
					end
					table.insert(action_bars[tween_index], {bar = new_bar, ending = new_bar_end, time = time})
					tween_time = tween_time + time
				end
				if not (val.easing_mid or val.easing_end) then
					add_bar(val.easing_start or val.time)
				end
			end
		end
		local new_bar_end = gui.clone(gui.get_node("action_end"))
		gui.set_parent(new_bar_end, new_timeline)
		gui.set_enabled(new_bar_end, true)
		gui.set(new_bar_end, "size.y", SET.tween_timeline_bar_height)
		action_bars[tween_index][0] = new_bar_end
		MOD.total_time = math.max(MOD.total_time, tween_time - SET.tween_padding_start)
	end
	MOD.total_time = MOD.total_time + SET.tween_padding_start + SET.tween_padding_end
	local box_y = 10 + (#MOD.tween_table * SET.tween_timeline_bar_height)
	gui.set_size(gui.get_node("timeline_box"), vmath.vector3(1200, box_y, 0))
	gui.set(gui.get_node("controls"), "position.y", box_y)
	gui.set(gui.get_node("scrubber"), "scale.y", #MOD.tween_table * SET.tween_timeline_bar_height)
	for tween_index, action_bar in ipairs(action_bars) do
		local time = MOD.tween_table[tween_index].time_offset + SET.tween_padding_start
		for key, val in ipairs(action_bar) do
			local start_pos = percent_to_position(time / MOD.total_time)
			local length = (val.time / MOD.total_time) * POSITION_MAX
			local end_pos = start_pos + length
			gui.set(val.bar, "position.x", start_pos)
			gui.set_size(val.bar, vmath.vector3(length, SET.tween_timeline_bar_height * 0.5, 0))
			--gui.set(val.bar, "size.x", length)
			gui.set(val.ending, "position.x", end_pos)
			gui.set(val.ending, "size.y", SET.tween_timeline_bar_height)
			if key == 1 then
				gui.set(action_bars[tween_index][0], "position.x", start_pos)
			end
			time = time + val.time
		end
	end
end

local function stop_playback(go_to_end)
	MOD.playback = false
	gui.cancel_animation(scrubber, "position.x")
	if go_to_end then
		move_scrubber(1)
	end
	gui.play_flipbook(gui.get_node("playback_play/text"), "play")
	SND.stop_music()
end

local function start_playback()
	MOD.playback = true
	local duration = (1 - MOD.scrubber_progress) * (MOD.total_time * (1 / SND.playback_speed))
	gui.play_flipbook(gui.get_node("playback_play/text"), "pause")
	gui.animate(scrubber, "position.x", POSITION_MAX + POSITION_MIN, gui.EASING_LINEAR, duration, 0, stop_playback)
	if MOD.prop_data.signal_z then
		local start = (MOD.prop_data.lowest_z / 3) + MOD.total_time * MOD.scrubber_progress - SET.tween_padding_start
		SND.play_music(start)
	end
end

local function close_preview()
	MOD.offset_position = vmath.vector3(0, 0, 0)
	MOD.offset_rotation = vmath.quat(0, 0, 0, 1)
	MOD.offset_scale = vmath.vector3(1, 1, 1)
	MOD.offset_euler = vmath.vector3(0, 0, 0)
	update_offset_fields()
	stop_playback()
	MOD.tween_preview = false
	set_button_colours()
	msg.post("#", hash("release_input_focus"))
	msg.post(".", hash("reset_tween"))
	change_bounds(bounding_node_transform)
	gui.set_enabled(gui.get_node("offset_box"), false)
	gui.set(gui.get_node("controls"), "position.y", 0)
	UI.unload_template(TAB_NAME)
	UI.load_template({"button_colour", "reset_view", "show_transforms"}, TAB_NAME)
	gui.set_enabled(gui.get_node("playback_box"), false)
	gui.set_enabled(gui.get_node("visibility_box"), false)
	delete_timeline()
	gui.set_enabled(gui.get_node("close_preview/button_white"), false)
	gui.set_enabled(time_display, false)
	gui.set_enabled(scrubber, false)
	gui.set_enabled(gui.get_node("label_model"), false)
	gui.set_position(button_box, BUTTON_BOX_POSITION)
	gui.set_size(button_box, BUTTON_BOX_SIZE)
	MOD.tween_table = nil
end


function move_scrubber(progress)
	MOD.previous_colour = nil
	MOD.scrubber_progress = progress
	local pos = POSITION_MAX * MOD.scrubber_progress + POSITION_MIN
	gui.set(scrubber, "position.x", pos)
	update_view()
	msg.post(".", hash("scrubber_moved"), {resume_afterwards = MOD.playback})
	if MOD.playback then
		stop_playback()
	end
end

local function handle_euler()
	local euler_rad = math.rad(vmath.vector3(-MOD.offset_euler.x, -MOD.offset_euler.y, MOD.offset_euler.z))
	MOD.offset_euler = math.deg(G.sanitise_euler(euler_rad))
	MOD.offset_rotation = G.euler_to_quat(MOD.offset_euler)
	MOD.offset_euler = G.quat_to_euler(MOD.offset_rotation)
	MOD.offset_euler.x = -MOD.offset_euler.x
	MOD.offset_euler.y = -MOD.offset_euler.y
	MOD.offset_euler = math.deg(G.sanitise_euler(math.rad(MOD.offset_euler)))
end

local function apply_prop_transform()
	local geo_z = 0
	MOD.offset_position.x = MOD.prop_data.position.x
	MOD.offset_position.y = MOD.prop_data.position.y
	if MOD.stationary then
		MOD.offset_position.z = MOD.prop_data.position.z
	else
		local z = math.huge
		local z_found = false
		for key, val in ipairs(MOD.prop_data.signal_z or {}) do
			z_found = true
			z = math.min(z, val)
		end
		if z_found then
			MOD.offset_position.z = MOD.prop_data.position.z - z
			geo_z = z
		else
			MOD.offset_position.z = SET.default_model_z_position
		end
	end
	MOD.offset_euler.x = MOD.prop_data.rotation.x
	MOD.offset_euler.y = MOD.prop_data.rotation.y
	MOD.offset_euler.z = MOD.prop_data.rotation.z
	MOD.offset_scale.x = MOD.prop_data.scale.x
	MOD.offset_scale.y = MOD.prop_data.scale.y
	MOD.offset_scale.z = MOD.prop_data.scale.z
	
	handle_euler()
	update_offset_fields()
	msg.post(".", hash("move_geo"), {z = geo_z})
end

local set_move_terrain
local function set_pov_lock(state)
	if state == nil then
		MOD.pov_lock = not MOD.pov_lock
	else
		MOD.pov_lock = state
	end
	if MOD.pov_lock then
		if not (MOD.move_terrain or MOD.stationary) then
			set_move_terrain(true)
		end
		gui.set_color(gui.get_node("lock_cam/button_white"), ACTIVE_BUTTON_COLOUR)
		MOD.target_x = 0
		MOD.target_y = 0
		MOD.target_z = 0
		msg.post(".", hash("reset_view"))
	else
		gui.set_color(gui.get_node("lock_cam/button_white"), vmath.vector4(1, 1, 1, 1))
		msg.post(".", hash("show_capsule"))
	end
end

function set_move_terrain(state)
	if state == nil then
		MOD.move_terrain = not MOD.move_terrain
	else
		MOD.move_terrain = state
	end
	if MOD.stationary then MOD.move_terrain = false end
	if MOD.move_terrain then
		gui.set_color(gui.get_node("move_terrain/button_white"), ACTIVE_BUTTON_COLOUR)
	else
		gui.set_color(gui.get_node("move_terrain/button_white"), vmath.vector4(1))
		if MOD.pov_lock then
			set_pov_lock(false)
		end
	end
end

local function set_playback_speed(speed)
	speed = speed or SND.playback_speed
	SND.playback_speed = speed
	gui.set_color(gui.get_node("playback_slow/button_white"), vmath.vector4(1))
	gui.set_color(gui.get_node("playback_normal/button_white"), vmath.vector4(1))
	gui.set_color(gui.get_node("playback_fast/button_white"), vmath.vector4(1))
	gui.set_color(gui.get_node("playback_fastest/button_white"), vmath.vector4(1))
	if speed == 0.5 then
		gui.set_color(gui.get_node("playback_slow/button_white"), ACTIVE_BUTTON_COLOUR)
	elseif speed == 1 then
		gui.set_color(gui.get_node("playback_normal/button_white"), ACTIVE_BUTTON_COLOUR)
	elseif speed == 2 then
		gui.set_color(gui.get_node("playback_fast/button_white"), ACTIVE_BUTTON_COLOUR)
	elseif speed == 4 then
		gui.set_color(gui.get_node("playback_fastest/button_white"), ACTIVE_BUTTON_COLOUR)
	end
	if MOD.playback then
		stop_playback()
		start_playback()
	end
end

local function show_visibility_box(state)
	if state == nil then
		SET.show_visibility_buttons = not SET.show_visibility_buttons
	else
		SET.show_visibility_buttons = state
	end
	gui.set_enabled(gui.get_node("visibility_box_buttons"), SET.show_visibility_buttons)
	if SET.show_visibility_buttons then
		UI.load_template({"hide_geo", "hide_props", "hide_beatcubes", "hide_grid", "hide_fog", "hide_beat", "button_colour"}, TAB_NAME)
	else
		UI.unload_template(TAB_NAME, {"hide_geo", "hide_props", "hide_beatcubes", "hide_grid", "hide_fog", "hide_beat", "button_colour"})
	end
end

function on_message(self, message_id, message, sender)
	if message_id == GET_MODEL_VIEWPORT then
		get_viewport()
	elseif message_id == hash("show") then
		get_viewport()
		set_button_colours()
		msg.post("#", hash("acquire_input_focus"))
	elseif message_id == hash("hide") and MOD.tween_preview then
		close_preview()
	elseif message_id == hash("disable_input") then
		msg.post("#", hash("release_input_focus"))
	elseif message_id == hash("dialog_closed") then
		msg.post("#", hash("acquire_input_focus"))
		if message.dialog == "dialog_props" then
			if message.prop_changed then
				stop_playback()
				move_scrubber(0)
				previous_transform_name = nil
				get_current_transform(1)
				apply_prop_transform()
				create_tween_sections()
				msg.post(".", hash("prepare_tweens"))
			end
		elseif message.dialog == "dialog_colours" then
			msg.post(".", "colours_changed")
		end
	elseif message_id == hash("resize_base") then
		change_bounds(bounding_node)
	elseif message_id == hash("resize_transform") then
		change_bounds(bounding_node_transform)
	elseif message_id == hash("update_transform_button") then
		set_transform_button()
	elseif message_id == hash("resize_rotate") then
		change_bounds(gui.get_node("rotate_box"))
	elseif message_id == hash("resume_playback") then
		start_playback()
	elseif message_id == hash("tween_preview") then
		MOD.tween_preview = true
		MOD.map_preview = message.preview_map
		MOD.total_time = 0
		set_playback_speed(1)
		MOD.stationary = MEM.level_data.moveMode and MEM.level_data.moveMode == "Stationary"
		set_pov_lock(false)
		msg.post(".", hash("reset_view"))
		move_scrubber(0)
		previous_transform_name = nil
		get_current_transform(1)
		gui.set_position(button_box, BUTTON_BOX_POSITION_PREVIEW)
		gui.set_size(button_box, BUTTON_BOX_SIZE_PREVIEW)
		msg.post("#", hash("acquire_input_focus"))
		change_bounds(bounding_node_preview)
		gui.set_enabled(gui.get_node("offset_box"), true)
		gui.set_enabled(gui.get_node("offset_box_2"), not MOD.map_preview)
		gui.set_enabled(scrubber, true)
		if MOD.prop_data then
			apply_prop_transform()
		elseif MOD.map_preview then
			msg.post(".", hash("move_geo"), {z = 0})
			MOD.tweenable_transforms = {}
		else
			MOD.offset_position.z = SET.default_model_z_position
		end
		gui.set_enabled(gui.get_node("playback_box"), true)
		gui.set_enabled(gui.get_node("visibility_box"), true)
		show_visibility_box(false)
		UI.load_template({"toggle_visibility"}, TAB_NAME)
		gui.set_enabled(timeline, true)
		gui.set_enabled(gui.get_node("close_preview/button_white"), true)
		gui.set_enabled(time_display, true)
		gui.set_enabled(gui.get_node("label_model"), true)
		
		MOD.model_index = message.model
		MOD.tween_table = {}
		selected_timeline = 1
		if not MOD.map_preview then
			update_offset_fields()
			gui.set_text(gui.get_node("position_z/text"), MOD.offset_position.z)
			local validation = {
				number = true,
				min = function() return -999 end,
				max = function() return 999 end,
				default = function() return 0 end
			}
			UI.load_text_field("position_x", 5, TAB_NAME, validation)
			UI.load_text_field("position_y", 5, TAB_NAME, validation)
			UI.load_text_field("position_z", 5, TAB_NAME, validation)
			UI.load_text_field("rotation_x", 5, TAB_NAME, validation)
			UI.load_text_field("rotation_y", 5, TAB_NAME, validation)
			UI.load_text_field("rotation_z", 5, TAB_NAME, validation)
			UI.load_text_field("scale_x", 5, TAB_NAME, validation)
			UI.load_text_field("scale_y", 5, TAB_NAME, validation)
			UI.load_text_field("scale_z", 5, TAB_NAME, validation)
			UI.load_template({"playback_back", "playback_forward", "playback_play", "playback_stop", "close_preview", "pick_model",
			"lock_cam", "find_prop", "move_terrain"}, TAB_NAME)
			selected_timeline = 0
			gui.set_text(gui.get_node("label_model"), MEM.art_data.table.propsDictionary[message.model].key)
			for i = 1, message.selected_transform do
				if MEM.art_data.table.propsDictionary[message.model].model_data.transform_list[i].tween then
					selected_timeline = selected_timeline + 1
				end
			end
			MOD.active_signals = {}
			MOD.prop_list_generated = false

			for key, val in ipairs(MEM.art_data.table.propsDictionary[MOD.model_index].model_data.transform_list) do
				if val.tween then
					table.insert(MOD.tween_table, val.tween)
					MOD.active_signals[val.tween.signal] = {}
				end
			end


			local signal_found
			if MEM.event_data.table then
				for key, val in ipairs(MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events) do
					if MOD.active_signals[val.payload] then
						local signal_time = tonumber(val.startSample) / SET.sample_rate
						table.insert(MOD.active_signals[val.payload], signal_time)
						signal_found = true
					end
				end
			end

			if not signal_found then
				MOD.active_signals = nil
			end

			for k, v in ipairs(MOD.tween_table) do
				MOD.tween_table[k] = G.expand_repeat_actions(v)
				local tween_table = MOD.tween_table[k]
				for key = #tween_table, 1, -1 do
					local val = tween_table[key]
					if val.time then
						val.time = tonumber(val.time)
					end
					if val.easing then
						local easing_tab = {}
						local x_diff = val.end_state.x - val.start_state.x
						local y_diff = val.end_state.y - val.start_state.y
						local z_diff = val.end_state.z - val.start_state.z
						if val.type == "R" then
							if x_diff > 180 then
								x_diff = x_diff - 360
							elseif x_diff < -180 then
								x_diff = x_diff + 360
							end
							if y_diff > 180 then
								y_diff = y_diff - 360
							elseif y_diff < -180 then
								y_diff = y_diff + 360
							end
							if z_diff > 180 then
								z_diff = z_diff - 360
							elseif z_diff < -180 then
								z_diff = z_diff + 360
							end
						end
						local node_tab = val.easing.nodes
						for i = 1, #node_tab - 1 do
							local s_x = val.start_state.x + (node_tab[i].comp * x_diff)
							local s_y = val.start_state.y + (node_tab[i].comp * y_diff)
							local s_z = val.start_state.z + (node_tab[i].comp * z_diff)
							local e_x = val.start_state.x + (node_tab[i + 1].comp * x_diff)
							local e_y = val.start_state.y + (node_tab[i + 1].comp * y_diff)
							local e_z = val.start_state.z + (node_tab[i + 1].comp * z_diff)
							local t = val.time * (node_tab[i + 1].time - node_tab[i].time)
							table.insert(easing_tab, {time = t, type = val.type, part = val.part, start_state = {x = s_x, y = s_y, z = s_z}, end_state = {x = e_x, y = e_y, z = e_z}})
						end
						table.remove(tween_table, key)
						for i = #easing_tab, 1, -1 do
							if i == #easing_tab then
								easing_tab[i].easing_end = true
							elseif i == 1 then
								easing_tab[i].easing_start = val.time
							else
								easing_tab[i].easing_mid = true
							end
							table.insert(tween_table, key, easing_tab[i])
						end
					end
				end
			end
			if SET.auto_set_tween_preview_prop then
				DIALOG.open(TAB_NAME, "dialog_props", {model = MEM.art_data.table.propsDictionary[MOD.model_index].key, autoclose = true})
			else
				create_tween_sections()
				msg.post(".", hash("prepare_tweens"))
			end
		else	-- if MOD.map_preview
			UI.load_template({"playback_back", "playback_forward", "playback_play", "playback_stop", "playback_slow", 
			"playback_normal", "playback_fast", "playback_fastest", "close_preview", "lock_cam", "move_terrain"}, TAB_NAME)
			local song_length = 0
			if MEM.level_data then
				set_move_terrain(true)
				set_pov_lock(false)
				if MEM.level_data.songLength then
					song_length = tonumber(MEM.level_data.songLength) or 0
				elseif MOD.culling_ranges then
					song_length = (MOD.max_culling_range - 3) * 16 / 3
				end
			end
			if song_length < 1 then song_length = 240 end
			local t = {}
			local size = SET.map_preview_partition_size
			if size == 0 then size = 999 end
			for i = 1, math.floor(song_length / size) do
				table.insert(t, {type = "W", time = size})
			end
			table.insert(t, {type = "W", time = song_length % size})
			MOD.tween_table = {t}
			local fake_data = {x = 0, y = 0, z = 0}
			MOD.prop_data = {position = fake_data, scale = fake_data, rotation = fake_data, lowest_z = 0, signal_z = {0}}
			create_tween_sections()
			
			msg.post(".", hash("prepare_tweens"))
		end
		if MOD.pov_lock then
			MOD.target_x = 0
			MOD.target_y = 0
		end
	end
end

local function get_current_action()
	local current_time = MOD.total_time * MOD.scrubber_progress
	local timeline_tab = MOD.tween_table[selected_timeline]
	local duration = timeline_tab.time_offset + SET.tween_padding_start
	if current_time < SET.tween_padding_start then
		return 0, duration
	end
	for key, val in ipairs(timeline_tab) do
		if not (val.easing_mid or val.easing_end) then
			local time = val.easing_start or tonumber(val.time)
			if time > 0.00000001 then
				if duration + time > current_time and ((duration + time) - current_time) > 0.00000001 then
					return key, duration
				else
					duration = duration + time
				end
			end
		end
	end
	if (current_time - duration) > 0 then
		return nil, duration
	else
		return #timeline_tab + 1, duration
	end
end

function get_current_transform(current_action)
	if not (SET.show_transform == 1 and MOD.tween_table) then return end
	current_action = current_action or get_current_action() or 1
	if current_action < 1 then current_action = 1 end
	local part
	if MOD.tween_table[selected_timeline][current_action] then
		part = MOD.tween_table[selected_timeline][current_action].part
	else
		part = MOD.tween_table[selected_timeline][#MOD.tween_table[selected_timeline]].part
	end
	if not part then
		for i = current_action - 1, 1, -1 do
			part = MOD.tween_table[selected_timeline][i].part
			if part then break end
		end
	end
	if not part then
		for i = current_action + 1, #MOD.tween_table[selected_timeline] do
			part = MOD.tween_table[selected_timeline][i].part
			if part then break end
		end
	end
	if previous_transform_name and (previous_transform_name == part) then
		return
	end
	previous_transform_name = part
	if part then
		for key, val in ipairs(MEM.art_data.table.propsDictionary[MOD.model_index].model_data.transform_list) do
			if part == val.name then
				MOD.visible_transform = key
				break
			end
		end
	else
		MOD.visible_transform = nil
	end
	msg.post(".", hash("show_transforms"))
end

local function evaluate_button(button)
	if button == "button_colour" then
		local current_dialog
		if current_bounding_node == bounding_node_transform then
			current_dialog = hash("transform")
			msg.post(UI.tab.dialog_transform.path, hash("release_input_focus"))
		elseif current_bounding_node == bounding_node_preview then
			current_dialog = hash("tween_preview")
		else
			current_dialog = hash("art")
		end
		DIALOG.open(TAB_NAME, "dialog_colours")
		--msg.post("#", hash("release_input_focus"))
		MOD.is_dragged = false
		MOD.camera_is_dragged = false
	elseif button == "pick_model" then
		DIALOG.open(TAB_NAME, "dialog_props", {model = MEM.art_data.table.propsDictionary[MOD.model_index].key})
	elseif button == "hide_fog" then
		if SET.hide_fog then
			gui.play_flipbook(gui.get_node("hide_fog/text"), "button_show_background")
		else
			gui.play_flipbook(gui.get_node("hide_fog/text"), "hide_fog")
		end
		msg.post(".", hash("hide_fog"))
	elseif button == "hide_beatcubes" then
		if SET.hide_beatcubes then
			gui.play_flipbook(gui.get_node("hide_beatcubes/text"), "show_beatcubes")
		else
			gui.play_flipbook(gui.get_node("hide_beatcubes/text"), "hide_beatcubes")
		end
		msg.post(".", hash("hide_beatcubes"))
	elseif button == "hide_props" then
		if SET.hide_props then
			gui.play_flipbook(gui.get_node("hide_props/text"), "find_prop")
		else
			gui.play_flipbook(gui.get_node("hide_props/text"), "hide_props")
		end
		msg.post(".", hash("hide_props"))
	elseif button == "hide_geo" then
		msg.post(".", hash("hide_geo"))
	elseif button == "reset_view" then
		set_pov_lock(false)
	elseif button == "hide_grid" then
		set_hide_grid(true)
		msg.post(".", hash("show_grid"))
	elseif button == "toggle_visibility" then
		show_visibility_box()
	elseif button == "show_transforms" then
		SET.show_transform = SET.show_transform + 1
		if SET.show_transform > 2 then
			SET.show_transform = 0
		end
		if SET.show_transform == 1 then
			if not SET.show_single_transform then
				SET.show_transform = 2
			elseif MOD.tween_preview then
				get_current_transform()
			end
		end
		set_transform_button()
	elseif button == "lock_cam" then
		set_pov_lock()
	elseif button == "move_terrain" then
		set_move_terrain()
	elseif button == "find_prop" then
		set_pov_lock(false)
		MOD.find_prop = true
	elseif button == "playback_back" then
		local current_action, start_time = get_current_action()
		local new_time
		if not current_action then
			new_time = start_time / MOD.total_time
		elseif current_action < 1 then
			new_time = 0
		elseif (MOD.total_time * MOD.scrubber_progress) - start_time > 0.00000001 then
			new_time = start_time / MOD.total_time
		else
			for i = 1, current_action - 1 do
				local function find_previous_action(index)
					local tab = MOD.tween_table[selected_timeline][index]
					if tab.easing_mid or tab.easing_end then
						return find_previous_action(index - 1)
					end
					return tab.easing_start or tonumber(tab.time)
				end
				local time = find_previous_action(current_action - i)
				if time > 0 then
					new_time = (start_time - time) / MOD.total_time
					break
				end
			end
			new_time = new_time or 0
		end
		move_scrubber(math.max(new_time, 0))
		get_current_transform(current_action)
	elseif button == "playback_forward" then
		local current_action, start_time = get_current_action()
		if current_action then
			if current_action > #MOD.tween_table[selected_timeline] then
				move_scrubber(1)
			else
				local time
				if current_action < 1 then
					time = 0
				else
					time = MOD.tween_table[selected_timeline][current_action].easing_start or tonumber(MOD.tween_table[selected_timeline][current_action].time)
				end
				move_scrubber(math.min((start_time + time) / MOD.total_time, 1))
			end
		else
			move_scrubber(1)
		end
		get_current_transform(current_action)
	elseif button == "playback_play" then
		if MOD.playback then
			stop_playback()
		else
			if not (MOD.scrubber_progress < 1) then
				MOD.playback = true
				move_scrubber(0)
				get_current_transform(1)
			else
				start_playback()
			end
		end
	elseif button == "playback_slow" then
		set_playback_speed(0.5)
	elseif button == "playback_normal" then
		set_playback_speed(1)
	elseif button == "playback_fast" then
		set_playback_speed(2)
	elseif button == "playback_fastest" then
		set_playback_speed(4)
	elseif button == "playback_stop" then
		stop_playback()
		move_scrubber(0)
		get_current_transform(1)
	elseif MOD.tween_preview and (button == "close_preview" or button == "escape") then
		if MOD.map_preview then
			msg.post(UI.tab.tab_file.path, hash("show"))
			msg.post(".", hash("hide"))
		else
			msg.post(UI.tab.dialog_tween.path, hash("tween_preview_closed"), {tween_index = selected_timeline})
			msg.post(UI.tab.dialog_transform.path, hash("enable"))
		end
		close_preview()
	end
end

local function evaluate_input(field, text)
	if field == "position_x" then
		MOD.offset_position.x = text
	elseif field == "position_y" then
		MOD.offset_position.y = text
	elseif field == "position_z" then
		MOD.offset_position.z = text
	elseif field == "rotation_x" then
		MOD.offset_euler.x = text
		handle_euler()
	elseif field == "rotation_y" then
		MOD.offset_euler.y = text
		handle_euler()
	elseif field == "rotation_z" then
		MOD.offset_euler.z = text
		handle_euler()
	elseif field == "scale_x" then
		MOD.offset_scale.x = text
	elseif field == "scale_y" then
		MOD.offset_scale.y = text
	elseif field == "scale_z" then
		MOD.offset_scale.z = text
	end
	update_offset_fields()
end

function update()
	if MOD.playback then
		update_view(true)
	end
end

function on_input(self, action_id, action)
	local function get_speed()
		if UI.shift_held then
			return SET.run_speed_multiplier
		else
			return 1
		end
	end
	
	if action_id == hash("mid_click") and action.pressed then
		MOD.cursor_locked = not MOD.cursor_locked
		window.set_mouse_lock(MOD.cursor_locked)
		return
	elseif action_id == hash("escape") and action.pressed and MOD.cursor_locked then
		MOD.cursor_locked = false
		window.set_mouse_lock(false)
		return
	elseif action_id == hash("w") then
		MOD.cam_target_z = MOD.cam_target_z - get_speed() * SET.model_move_sensitivity / 20
		return
	elseif action_id == hash("s") then
		MOD.cam_target_z = MOD.cam_target_z + get_speed() * SET.model_move_sensitivity / 20
		return
	elseif action_id == hash("a") then
		MOD.cam_target_x = MOD.cam_target_x - get_speed() * SET.model_move_sensitivity / 20
		return
	elseif action_id == hash("d") then
		MOD.cam_target_x = MOD.cam_target_x + get_speed() * SET.model_move_sensitivity / 20
		return
	elseif action_id == hash("e") then
		MOD.cam_target_y = MOD.cam_target_y + get_speed() * SET.model_move_sensitivity / 20
		return
	elseif action_id == hash("q") then
		MOD.cam_target_y = MOD.cam_target_y - get_speed() * SET.model_move_sensitivity / 20
		return
	elseif action_id == hash("scroll_up") and MOD.total_time then
		mouse_wheel_scroll_target = mouse_wheel_scroll_target + 0.5 / MOD.total_time
		if action.released then
			mouse_wheel_scroll_target = G.clamp(MOD.scrubber_progress + mouse_wheel_scroll_target, 0, 1)
			move_scrubber(mouse_wheel_scroll_target)
			mouse_wheel_scroll_target = 0
		end
	elseif action_id == hash("scroll_down") and MOD.total_time then
		mouse_wheel_scroll_target = mouse_wheel_scroll_target - 0.5 / MOD.total_time
		if action.released then
			mouse_wheel_scroll_target = G.clamp(MOD.scrubber_progress + mouse_wheel_scroll_target, 0, 1)
			move_scrubber(mouse_wheel_scroll_target)
			mouse_wheel_scroll_target = 0
		end
	end
	
	if not action_id then
		if MOD.is_dragged or MOD.cursor_locked then
			MOD.target_x = MOD.target_x - action.dx * SET.model_rotation_sensitivity / 5
			MOD.target_y = MOD.target_y + action.dy * SET.model_rotation_sensitivity / 5
			MOD.target_y = math.max(-90, math.min(90, MOD.target_y))
		end
		if MOD.camera_is_dragged then
			MOD.cam_target_x = MOD.cam_target_x - action.dx * SET.model_move_sensitivity / 60
			MOD.cam_target_y = MOD.cam_target_y - action.dy * SET.model_move_sensitivity / 60
		end
		if MOD.timeline_dragged then
			stop_playback()
			local pos = gui.get_screen_position(scrubber)
			local min_x = gui.get_screen_position(gui.get_node("min")).x
			local max_x = gui.get_screen_position(gui.get_node("max")).x
			pos.x = math.min(math.max(action.screen_x, min_x), max_x)
			move_scrubber((pos.x - min_x) / (max_x - min_x))
			get_current_transform()
			MOD.timeline_dragged = true
		end
		if MOD.is_dragged or MOD.camera_is_dragged or MOD.cursor_locked then
			return
		else
			UI.on_input(TAB_NAME, action_id, action, evaluate_button)
			return
		end
	elseif MOD.tween_preview and action.pressed and action_id == hash("space") then
		if MOD.playback then
			stop_playback()
		else
			if not (MOD.scrubber_progress < 1) then
				MOD.playback = true
				move_scrubber(0)
				get_current_transform(1)
			else
				start_playback()
			end
		end
		return
	elseif action.released and MOD.camera_is_dragged and action_id == hash("r_click") then
		MOD.camera_is_dragged = false
		return
	elseif action.released and (MOD.is_dragged or MOD.timeline_dragged) and action_id == hash("touch") then
		MOD.is_dragged = false
		MOD.timeline_dragged = false
		return
	elseif action.x and gui.pick_node(current_bounding_node, action.x, action.y) then
		if MOD.is_dragged or MOD.camera_is_dragged or MOD.timeline_dragged then
			return
		end
		if MOD.tween_preview and gui.pick_node(timeline, action.x, action.y) then
			if action_id == hash("touch") then
				stop_playback()
				local pos = gui.get_screen_position(scrubber)
				local min_x = gui.get_screen_position(gui.get_node("min")).x
				local max_x = gui.get_screen_position(gui.get_node("max")).x
				pos.x = math.min(math.max(action.screen_x, min_x), max_x)
				move_scrubber((pos.x - min_x) / (max_x - min_x))
				get_current_transform()
				MOD.timeline_dragged = true
			elseif action_id == hash("r_click") and action.released then
				for key, val in ipairs(timelines) do
					if gui.pick_node(val, action.x, action.y) then
						select_timeline(key)
						break
					end
				end
			end
		elseif not (gui.pick_node(button_box, action.x, action.y) or gui.pick_node(playback_box, action.x, action.y) or (MOD.tween_preview and
		(gui.pick_node(close_button, action.x, action.y) or gui.pick_node(gui.get_node("visibility_box"), action.x, action.y) or
		(SET.show_visibility_buttons and gui.pick_node(gui.get_node("visibility_box_buttons"), action.x, action.y)))))
			then
			if action_id == hash("touch") and action.pressed then
				MOD.is_dragged = true
			elseif action_id == hash("r_click") and action.pressed then
				MOD.camera_is_dragged = true
			end
		end
	end
	UI.on_input(TAB_NAME, action_id, action, evaluate_button, evaluate_input, not MOD.tween_preview)
end