local UI = require "modules.ui"
local MEM = require "modules.memory"
local G = require "modules.global"
local COL = require "modules.colours"
local SET = require "modules.settings"
local DIALOG = UI.DIALOG
local TAB_NAME = "tab_file"
local MOD = require "modules.models"
local SND = require "modules.sound"

local files_to_export

local function set_checkbox(checkbox, value)
	if value then
		gui.set_text(gui.get_node(checkbox.."/text"), "X")
	else
		gui.set_text(gui.get_node(checkbox.."/text"), "")
	end
end

function init(self)
	gui.set_render_order(1)
	gui.set_text(gui.get_node("version_label"), "Version "..sys.get_config("project.version"))
	UI.load_template({"exit", "load_dir", "load_file", "load_zip", "unload_all", "export_all", "export_folder_checkbox", "import_changes",
	"import_checkbox", "degeomance", "import_level", "import_events", "import_beat", "import_models", "help", "map_preview"}, TAB_NAME)
	if SET.I_am_Klear then
		UI.load_template("klear_button", TAB_NAME)
	else
		gui.set_enabled(gui.get_node("klear_button/button_white"), false)
	end
	set_checkbox("import_checkbox", SET.import_changes_from_zip)
	set_checkbox("export_folder_checkbox", SET.create_folder_on_export)
	set_checkbox("import_level", SET.import_level_changes)
	set_checkbox("import_events", SET.import_event_changes)
	set_checkbox("import_beat", SET.import_beat_changes)
	set_checkbox("import_models", SET.import_model_changes)
end

local function run_export_fn()
	local export_count, expected_count = 0, 10
	for key, val in ipairs(files_to_export) do
		if val.fn(val.path) then
			G.update_navbar(val.text_fail)
			expected_count = expected_count - 1
		else
			export_count = export_count + 1
			G.update_navbar(val.text)
		end
	end
	if MEM.level_data and MEM.level_data.remixTarget then
		expected_count = expected_count - 1
	end
	if MEM.level_data and not MEM.level_data.art then
		expected_count = expected_count - 1
	end
	if export_count < expected_count then
		G.update_navbar(export_count.." files exported")
	else
		G.update_navbar(export_count.." files exported")
		G.update_navbar("The export is a full map.")
	end
	files_to_export = nil
end

local function check_for_reset()
	if MEM.event_reloaded then
		MEM.event_reloaded = nil
	end
	if MEM.art_reloaded then
		msg.post("/art#tab_art", hash("reset"))
		MEM.art_reloaded = nil
	end
	if MEM.beat_reloaded then
		msg.post("/beat#tab_beat", hash("reset"))
		MEM.beat_reloaded = nil
	end
	if MEM.slices_reloaded then
		msg.post("/meta#tab_meta", hash("reset"))
		MEM.slices_reloaded = nil
	end
end

local function export_level(path)
	local f = G.safe_output(path)
	if f then
		MEM.export_json(MEM.level_data)
		io.close(f)
	end
end

local function export_event(path)
	local f = G.safe_output(path)
	if f then
		MEM.export_json(MEM.event_data.table)
		io.close(f)
	end
end

local function get_tween_script(tween_data, model_name)
	if not tween_data then return end
	local str = ""
	local deletion_count, save_original
	tween_data, deletion_count, save_original = G.expand_repeat_actions(tween_data)
	if model_name then
		if deletion_count > 1 then
			G.update_navbar(deletion_count.." invalid repeat actions have been removed from tween of "..model_name)
		elseif deletion_count > 0 then
			G.update_navbar("An invalid repeat action has been removed from tween of "..model_name)
		end
	end

	for key, val in ipairs(tween_data) do
		if val.type == "W" then
			str = str..val.type..val.time..";"
		else
			if val.easing then
				local node_values = G.separate_easing(val)
				for k, v in ipairs(node_values) do
					str = str..val.type..val.part..";"..v.s.x..","..v.s.y..","..v.s.z..";"..v.e.x..","..v.e.y..","..v.e.z..";"..v.t..";"
				end
			else
				str = str..val.type..val.part..";"..val.start_state.x..","..val.start_state.y..","
				str = str..val.start_state.z..";"..val.end_state.x..","..val.end_state.y..","..val.end_state.z..";"..val.time..";"
			end
		end
	end
	return str, save_original
end

local function export_art(path)
	local is_dynamic = {}
	local model_table = MEM.art_data.table
	for key, val in ipairs(model_table.propsDictionary) do
		for k, v in ipairs(val.model_data.transform_list) do
			for i = #v.tab.components, 1, -1 do
				if (v.tab.components[i].type == "ScriptedTween") or (v.tab.components[i].type == "LevelEventReceiver") then
					table.remove(v.tab.components, i)
				end
			end
			if v.tween then
				local tween_script, save_original = get_tween_script(v.tween, val.key)
				if tween_script then
					table.insert(v.tab.components, {type = "ScriptedTween", Script = tween_script, _key_sort = {"type", "Script"}})
					table.insert(v.tab.components, {type = "LevelEventReceiver", EventId = v.tween.signal,
					ActionType = "ScriptedTweenTrigger", _key_sort = {"type", "EventId", "ActionType"}})
					if save_original then
						MEM.geomancer_meta.props[val.key] = MEM.geomancer_meta.props[val.key] or {tweens = {}}
						MEM.geomancer_meta.props[val.key].tweens[k] = {table = v.tween, script = tween_script, signal = v.tween.signal}
						MEM.geomancer_meta.props[val.key].tweens[k].table.signal = nil
					end
				end
			end
		end
		is_dynamic[val.key] = val.dynamic
	end
	table.insert(model_table.propsDictionary, 1, MEM.art_data.placeholder)
	model_table.staticProps = model_table.staticProps or {}
	model_table.dynamicProps = model_table.dynamicProps or {}
	model_table.staticCullingRanges = model_table.staticCullingRanges or {}
	model_table.dynamicCullingRanges = model_table.dynamicCullingRanges or {}
	for i = #model_table.staticProps, 1, -1 do
		if is_dynamic[model_table.staticProps[i].name] then
			table.insert(model_table.dynamicProps, table.remove(model_table.staticProps, i))
		end
	end
	for i = #model_table.dynamicProps, 1, -1 do
		if not is_dynamic[model_table.dynamicProps[i].name] then
			table.insert(model_table.staticProps, table.remove(model_table.dynamicProps, i))
		end
	end
	local moved_static_ranges, moved_dynamic_ranges = {}, {}
	for i = #model_table.staticCullingRanges, 1, -1 do
		local range = model_table.staticCullingRanges[i]
		for j = #range.members, 1, -1 do
			if is_dynamic[range.members[j].name] then
				moved_static_ranges[range.range] = moved_static_ranges[range.range] or {}
				table.insert(moved_static_ranges[range.range], table.remove(range.members, j))
			end
		end
		if #range.members < 1 then
			table.remove(model_table.staticCullingRanges, i)
		end
	end
	for i = #model_table.dynamicCullingRanges, 1, -1 do
		local range = model_table.dynamicCullingRanges[i]
		for j = #range.members, 1, -1 do
			if not is_dynamic[range.members[j].name] then
				moved_dynamic_ranges[range.range] = moved_dynamic_ranges[range.range] or {}
				table.insert(moved_dynamic_ranges[range.range], table.remove(range.members, j))
			end
		end
		if #range.members < 1 then
			table.remove(model_table.dynamicCullingRanges, i)
		end
	end
	for key, val in ipairs(model_table.staticCullingRanges) do
		if moved_dynamic_ranges[val.range] then
			for k, v in ipairs(moved_dynamic_ranges[val.range]) do
				table.insert(val.members, v)
			end
			moved_dynamic_ranges[val.range] = nil
		end
	end
	for key, val in pairs(moved_dynamic_ranges) do
		table.insert(model_table.staticCullingRanges, {range = key, members = val, _key_sort = {"members", "range"}})
	end

	for key, val in ipairs(model_table.dynamicCullingRanges) do
		if moved_static_ranges[val.range] then
			for k, v in ipairs(moved_static_ranges[val.range]) do
				table.insert(val.members, v)
			end
			moved_static_ranges[val.range] = nil
		end
	end
	for key, val in pairs(moved_static_ranges) do
		table.insert(model_table.dynamicCullingRanges, {range = key, members = val, _key_sort = {"members", "range"}})
	end

	local function range_to_number(range_str)
		local comma = string.find(range_str, ",")
		local first = tonumber(string.sub(range_str, 1, comma - 1))
		local second = tonumber(string.sub(range_str, comma +1))
		return first + (second * 0.001)
	end

	table.sort(model_table.staticCullingRanges, function(a, b) return range_to_number(a.range) < range_to_number(b.range) end)
	table.sort(model_table.dynamicCullingRanges, function(a, b) return range_to_number(a.range) < range_to_number(b.range) end)
	
	if #model_table.dynamicProps < 0 then
		model_table.dynamicProps = nil
	end
	if #model_table.dynamicCullingRanges < 0 then
		model_table.dynamicCullingRanges = nil
	end

	local key_sort_list = {staticProps = true, dynamicProps = true, staticCullingRanges = true, dynamicCullingRanges = true}

	local colour_index
	for i = #model_table._key_sort, 1, -1 do
		if key_sort_list[model_table._key_sort[i]] then
			table.remove(model_table._key_sort, i)
		end
		if model_table._key_sort[i] == "colors" then
			colour_index = i + 1
		end
	end

	if model_table.dynamicCullingRanges then
		table.insert(model_table._key_sort, colour_index, "dynamicCullingRanges")
	end
	if model_table.dynamicProps then
		table.insert(model_table._key_sort, colour_index, "dynamicProps")
	end
	table.insert(model_table._key_sort, colour_index, "staticCullingRanges")
	table.insert(model_table._key_sort, colour_index, "staticProps")
	
	local f = G.safe_output(path)
	if f then
		MEM.export_json(MEM.art_data.table)
		io.close(f)
	end

	table.remove(model_table.propsDictionary, 1)
	model_table.staticProps = model_table.staticProps or {}
	model_table.dynamicProps = model_table.dynamicProps or {}
	model_table.staticCullingRanges = model_table.staticCullingRanges or {}
	model_table.dynamicCullingRanges = model_table.dynamicCullingRanges or {}
end

local function export_beat(path)
	local f = G.safe_output(path)
	if f then
		MEM.export_json(MEM.beat_data.table)
		io.close(f)
	end
end

local function export_geo(path)
	local f = G.safe_output(path)
	if f then
		MEM.export_json(MEM.geo_data.table)
		io.close(f)
	end
end

local function export_pw_meta(path)
	local f = G.safe_output(path)
	if f then
		MEM.export_json(MEM.meta_data)
		io.close(f)
	end
end

local function export_geomancer_meta(path)
	if not (type(MEM.geomancer_meta) == "table" and next(MEM.geomancer_meta)) then
		MEM.geomancer_meta = nil
		return true
	end
	local f = G.safe_output(path)
	if f then
		io.write(json.encode(MEM.geomancer_meta))
		io.close(f)
	end
	for key, val in pairs(MEM.geomancer_meta.props) do
		if val.tweens then
			for k, v in pairs(val.tweens) do
				v.table.signal = v.signal
			end
		end
	end
	MEM.geomancer_meta = nil
end

local function export_sequences(path)
	local f = G.safe_output(path)
	if f then
		io.write(MEM.sequence_data.string)
		io.close(f)
	end
end

local function export_binary(path, data)
	local file = io.open(path, "wb")
	local f = G.safe_output(file)
	if f then
		io.write(data)
		io.close(f)
	end
end

local function export_all(overwrite)
	if UI.tab.tab_level.state or UI.tab.tab_event.state or UI.tab.tab_geo.state or UI.tab.tab_beat.state or UI.tab.tab_meta.state or UI.tab.tab_art.state then
		local _, path
		if overwrite then
			_, path = diags.open_folder(SET.default_path_export)
		else
			_, path = diags.open_folder(SET.default_path_export_overwrite)
		end
		if path then
			local function get_name(s)
				if s then
					local ext = string.find(s, "%.")
					return string.sub(s, 1, ext - 1)
				end
			end
			local function get_art_name(s)
				if s then
					local shared = string.find(MEM.art_data.filename, "_SharedArt") or -7 -- In case _SharedArt not found in filename just remove the extension
					return string.sub(MEM.art_data.filename, 1, shared - 1)
				end
			end
			local filename_sequence, filename_art, filename_poster, filename_ogg
			local filename_common
			if MEM.level_data then
				if not MEM.level_data.remixTarget then
					filename_ogg = MEM.level_data.songLocation
				end
				filename_sequence = MEM.level_data.sequenceDictionary
				filename_art = MEM.level_data.sharedLevelArt
				filename_poster = MEM.level_data.art
				if filename_art then
					local ext = string.find(filename_art, "%.")
					filename_common = string.sub(filename_art, 1, ext - 11)
				end
			end
			filename_common = filename_common or get_name(MEM.beat_data.filename) or get_name(MEM.event_data.filename) or get_name(MEM.geo_data.filename) or get_art_name(MEM.art_data.filename) or "map"
			filename_sequence = filename_sequence or filename_common.."_sequenceDictionary.pw_seq"
			filename_art = filename_art or filename_common.."_SharedArt.pw_art"
			filename_poster = filename_poster or filename_common..".png"
			filename_ogg = filename_ogg or filename_common..".ogg"
			
			MEM.geomancer_meta = {version = sys.get_config("project.version"), props = {}}


			
			if not overwrite then
				local export_count, expected_count = 0, 10
				path = path.."\\"..filename_common.."_geomanced"
				if not lfs.mkdir(path) then
					local index = 0
					repeat
						index = index + 1
						if index > 1000 then
							G.update_navbar("Cannot create folder. Export aborted")
							return
						end
					until lfs.mkdir(path.."("..index..")")
					path = path.."("..index..")"
				end
				G.update_navbar("Exporting files to "..path, true)
				if next(MEM.level_data) then
					export_level(path.."\\level.pw")
					G.update_navbar("Level settings exported")
					export_count = export_count + 1
				end
				if MEM.event_data.table then
					export_event(path.."\\"..filename_common..".pw_event")
					G.update_navbar("Events exported")
					export_count = export_count + 1
				end
				if MEM.art_data.table then
					export_art(path.."\\"..filename_art)
					G.update_navbar("Model data exported")
					export_count = export_count + 1
				end
				if MEM.beat_data.table then
					export_beat(path.."\\"..filename_common..".pw_beat")
					G.update_navbar("Enemies exported")
					export_count = export_count + 1
				end
				if MEM.geo_data.table then
					export_geo(path.."\\"..filename_common..".pw_geo")
					G.update_navbar("Geo exported")
					export_count = export_count + 1
				end
				if next(MEM.meta_data) then
					export_pw_meta(path.."\\do_not_ship.pw_meta")
					G.update_navbar("Editor metadata exported")
					export_count = export_count + 1
				end
				if MEM.sequence_data.string then
					export_sequences(path.."\\"..filename_sequence)
					G.update_navbar("Sequences exported")
					export_count = export_count + 1
				end
				if MEM.music and MEM.music_raw then
					export_binary(path.."\\"..filename_ogg, MEM.music_raw)
					G.update_navbar("Music exported")
					export_count = export_count + 1
				else
					if MEM.level_data and MEM.level_data.remixTarget then
						expected_count = expected_count - 1
					end
				end
				if MEM.poster then
					export_binary(path.."\\"..filename_poster, MEM.poster)
					G.update_navbar("Poster exported")
					export_count = export_count + 1
				else
					if MEM.level_data and not MEM.level_data.art then
						expected_count = expected_count - 1
					end
				end
				if export_geomancer_meta(path.."\\"..filename_common..".geomancer") then
					G.update_navbar("Failed to generate metadata", false)
					expected_count = expected_count - 1
				else
					G.update_navbar("Geomancer metadata exported", false)
					export_count = export_count + 1
				end
				if export_count < expected_count then
					G.update_navbar(export_count.." files exported to "..path)
				else
					G.update_navbar(export_count.." files exported to "..path)
					G.update_navbar("The export is a full map.")
				end
			else
				G.update_navbar("Starting export", true)
				files_to_export = {}
				local full_path
				if next(MEM.level_data) then
					full_path = path.."\\level.pw"
					table.insert(files_to_export, {fn = export_level, path = full_path, exists = sys.exists(full_path), text = "Level settings exported"})
				end
				if MEM.event_data.table then
					full_path = path.."\\"..filename_common..".pw_event"
					table.insert(files_to_export, {fn = export_event, path = full_path, exists = sys.exists(full_path), text = "Events exported"})
				end
				if MEM.art_data.table then
					full_path = path.."\\"..filename_art
					table.insert(files_to_export, {fn = export_art, path = full_path, exists = sys.exists(full_path), text = "Model data exported"})
				end
				if MEM.beat_data.table then
					full_path = path.."\\"..filename_common..".pw_beat"
					table.insert(files_to_export, {fn = export_beat, path = full_path, exists = sys.exists(full_path), text = "Enemies exported"})
				end
				if MEM.geo_data.table then
					full_path = path.."\\"..filename_common..".pw_geo"
					table.insert(files_to_export, {fn = export_geo, path = full_path, exists = sys.exists(full_path), text = "Geo exported"})
				end
				if MEM.poster then
					full_path = path.."\\"..filename_poster
					table.insert(files_to_export, {fn = function(_path) export_binary(_path, MEM.poster) end, path = full_path, exists = sys.exists(full_path), text = "Poster exported"})
				end
				if MEM.music and MEM.music_raw then
					full_path = path.."\\"..filename_ogg
					table.insert(files_to_export, {fn = function(_path) export_binary(_path, MEM.music_raw) end, path = full_path, exists = sys.exists(full_path), text = "Music exported"})
				end
				if MEM.sequence_data.string then
					full_path = path.."\\"..filename_sequence
					table.insert(files_to_export, {fn = export_sequences, path = full_path, exists = sys.exists(full_path), text = "Sequences exported"})
				end
				if next(MEM.meta_data) then
					full_path = path.."\\do_not_ship.pw_meta"
					table.insert(files_to_export, {fn = export_pw_meta, path = full_path, exists = sys.exists(full_path), text = "do_not_ship.pw_meta exported."})
				end
				full_path = path.."\\"..filename_common..".geomancer"
				table.insert(files_to_export, {fn = export_geomancer_meta, path = full_path, exists = sys.exists(full_path), text = "Geomancer metadata exported", text_fail = "Failed to generate metadata"})
				
				local overwrite_count = 0
				for key, val in ipairs(files_to_export) do
					if val.exists then
						overwrite_count = overwrite_count + 1
					end
				end
				if overwrite_count < 1 then
					run_export_fn()
				elseif not SET.confirm_file_overwrite then
					G.update_navbar("Exporting files to "..path.."\nEXISTING FILES ARE BEING OVERWRITTEN", true)
					run_export_fn()
				else
					local title = overwrite_count.." files will be overwritten. Continue with export?"
					DIALOG.open(TAB_NAME, "dialog_confirm", {title = title, button_1 = "Overwrite", button_3 = "Cancel", subject = "overwrite_export"})
				end
			end
		end
	else
		G.update_navbar("Nothing to export", true)
	end
end

local advanced_sequences = 	{
	__Flying_ATTACK = true,
	["Zig_shoot _Zag_shoot"] = true,
	Strafe_shoot_retreat = true,
	FWD_RGHT_FWD_SHT = true,
	["STRAFE SHOOT x3"] = true,
	--		High_FlyingSkull Basic = true,
	--		ONBEAT_High_FlyingSkull = true,
	--		FlyingSkull Basic = true,
	--		FlyingSkull Short
	--		DefaultEnemySequence_Jetpack = true,
	BeatSpawn_Jetpack_Stationary = true,
	["_Run Roll Shoot"] = true,
	--		__SniperJoeTest = true,
	--		ImmediateDespawn = true,
	CrookedTestSequence = true,
	["EmptyEnemySequence 1"] = true,
	Run_Slide_Shoot_01 = true,
	_VaultShoot_01 = true,
	ENME_SEQ_06 = true,
	ENME_SEQ_07 = true,
	StrafeRightLeft = true,
	Canter_Forward_Shoot = true,
	TestEnemySequence = true
}

local function degeomance()
	if not (UI.tab.tab_level.state or UI.tab.tab_event.state or UI.tab.tab_beat.state or UI.tab.tab_art.state or UI.tab.tab_meta.state) then
		G.update_navbar("You must open a map first.", true)
		return
	end
	G.update_navbar("De-geomancing map", true)
	if UI.tab.tab_level.state then
		local change = false
		if not (MEM.level_data.previewTime == 0) then
			MEM.level_data.previewTime = 0
			G.update_navbar("Preview time reset to 0")
			change = true
		end
		if not (MEM.level_data.moveMode == "Moving") then
			MEM.level_data.moveMode = "Moving"
			G.update_navbar("Move mode set to Moving")
			change = true
		end
		if not change then
			G.update_navbar("No level info changes necessary")
		end
	end
	if UI.tab.tab_event.state then
		local nobeat_count = #MEM.event_data.table.eventsData[MEM.event_data.nobeat_track_index].events
		local event_count = #MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events
		local tempo_count = #MEM.event_data.table.tempoSections
		MEM.event_data.table.eventsData[MEM.event_data.nobeat_track_index].events = {}
		local skipped_count = 0
		if not MEM.level_data.obstacleSet then
			for key = event_count, 1, -1 do
				local payload = MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events[key].payload
				if (payload == "PillarDrop") or (payload == "RisePillar") then
					event_count = event_count - 1
				else
					table.remove(MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events, key)
				end
			end
		elseif MEM.level_data.obstacleSet == "AirDrop" then
			for key = event_count, 1, -1 do
				local payload = MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events[key].payload
				if payload == "PillarDrop" then
					event_count = event_count - 1
					skipped_count = skipped_count + 1
				else
					table.remove(MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events, key)
				end
			end
			if MEM.beat_data.obstacle_list then
				if skipped_count < #MEM.beat_data.obstacle_list then
					local new_event_count = #MEM.beat_data.obstacle_list - skipped_count
					for i = 1, new_event_count do
						msg.post(UI.tab.tab_event.path, hash("add_event"), {start_sample = i, signal = "PillarDrop"})
					end
					if new_event_count > 1 then
						G.update_navbar("Created "..new_event_count.." PillarDrop events at the start of the map.")
					else
						G.update_navbar("Created a PillarDrop event at the start of the map.")
					end
				end
			end
		elseif MEM.level_data.obstacleSet == "Spooky" then
			for key = event_count, 1, -1 do
				local payload = MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events[key].payload
				if payload == "RisePillar" then
					event_count = event_count - 1
					skipped_count = skipped_count + 1
				else
					table.remove(MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events, key)
				end
			end
			if MEM.beat_data.obstacle_list then
				if skipped_count < #MEM.beat_data.obstacle_list then
					local new_event_count = #MEM.beat_data.obstacle_list - skipped_count
					for i = 1, new_event_count do
						msg.post(UI.tab.tab_event.path, hash("add_event"), {start_sample = i, signal = "RisePillar"})
					end
					if new_event_count > 1 then
						G.update_navbar("Created "..new_event_count.." RisePillar events at the start of the map.")
					else
						G.update_navbar("Created a RisePillar event at the start of the map.")
					end
				end
			end
		else
			MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events = {}
		end


		if #MEM.event_data.table.tempoSections > 1 then
			MEM.event_data.table.tempoSections = {MEM.event_data.table.tempoSections[1]}
		end
		local change = false
		if nobeat_count > 1 then
			G.update_navbar("Removed "..nobeat_count.." no-beat sections")
			change = true
		elseif nobeat_count > 0 then
			G.update_navbar("Removed one no-beat section")
			change = true
		end
		if event_count > 1 then
			G.update_navbar("Removed "..event_count.." event triggers")
			change = true
		elseif event_count > 0 then
			G.update_navbar("Removed one event trigger")
			change = true
		end
		if tempo_count > 2 then
			G.update_navbar("Removed "..(tempo_count - 1).." tempo sections")
			change = true
		elseif tempo_count > 1 then
			G.update_navbar("Removed one tempo section")
			change = true
		end
		if not change then
			G.update_navbar("No event file changes necessary")
		end
	end
	if UI.tab.tab_art.state then
		msg.post("/art#tab_art", hash("degeomance"))
	end
	if UI.tab.tab_beat.state then
		local obstacle_count, enemy_type_count, sequence_count = 0, 0, 0
		local obstacle_types = {Wall = "Sidestep", TunnelTall = "LimboTall", TunnelShort = "LimboShort"}
		for key, val in ipairs(MEM.beat_data.obstacle_list) do
			local obstacle_data = MEM.beat_data.table.beatData[val.beat_data_key].obstacles[val.obstacles_key]
			if obstacle_types[obstacle_data.type] then
				obstacle_count = obstacle_count + 1
				obstacle_data.type = obstacle_types[obstacle_data.type]
			end
		end

		local enemy_names = {
			Normal = "normal",
			Tough = "tough",
			ChuckNorris = "chuck",
			["Mounted Enemy"] = "horse",
			Shield = "shield",
			["Normal Turret"] = "turret",
			["Minigun Turret"] = "minigun",
			FlyingBomb = "skull",
			["Trap Enemy"] = "trap"
		}

		for key, val in ipairs(MEM.beat_data.enemy_list) do
			local enemy_data = MEM.beat_data.table.beatData[val.beat_data_key].targets[val.enemies_key]
			if enemy_data.enemyType == "FlyingBomb" then
				enemy_data.enemyType = SET.degeomance_skull
				MEM.beat_data.enemy_types[enemy_names[SET.degeomance_skull]] = true
				enemy_type_count = enemy_type_count + 1
			elseif val.type == "Trap Enemy" then
				enemy_data.enemyType = SET.degeomance_glitched_enemy
				MEM.beat_data.enemy_types[enemy_names[SET.degeomance_glitched_enemy]] = true
			end
			if advanced_sequences[enemy_data.enemySequence] then
				enemy_data.enemySequence = SET.degeomance_sequence
				sequence_count = sequence_count + 1
			end
			MEM.beat_data.enemy_types.FlyingBomb = false
			MEM.beat_data.enemy_types["Trap Enemy"] = false
		end
		if obstacle_count > 1 then
			G.update_navbar("Changed "..obstacle_count.." obstacles")
		elseif obstacle_count > 0 then
			G.update_navbar("Changed one obstacle")
		end
		if enemy_type_count > 1 then
			G.update_navbar("Changed "..enemy_type_count.." enemy types")
		elseif enemy_type_count > 0 then
			G.update_navbar("Changed one enemy type")
		end
		if sequence_count > 1 then
			G.update_navbar("Changed "..sequence_count.." sequences")
		elseif sequence_count > 0 then
			G.update_navbar("Changed one sequence")
		end
	end
	if UI.tab.tab_meta.state then

	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("hide") then
		msg.post("#", hash("disable"))
		msg.post("#", hash("release_input_focus"))
		DIALOG.close_all(TAB_NAME)
	elseif message_id == hash("show") then
		msg.post("#", hash("enable"))
		msg.post("#", hash("acquire_input_focus"))
	elseif message_id == hash("export_all") then
		export_all(not SET.create_folder_on_export)
	elseif message_id == hash("dialog_closed") then
		msg.post("#", hash("acquire_input_focus"))
		if message.dialog == "dialog_confirm" then
			if message.subject == "overwrite_export" then
				if message.button == 1 then 			-- buttons are 1 = overwrite, 3 = cancel
					run_export_fn()
				else
					files_to_export = nil
					msg.post("/navbar#navbar", hash("update_status"), {text = "Export aborted", clear = true})
				end
			elseif message.subject == "degeomance_confirm" then
				if message.button == 1 then
					degeomance()
				end
			end
		end
	end
end

local function check_geomancer_meta()
	if MEM.art_data.table and MEM.geomancer_meta and MEM.geomancer_meta.props and next(MEM.geomancer_meta.props) then
		for key, val in ipairs(MEM.art_data.table.propsDictionary) do
			if MEM.geomancer_meta.props[val.key] then
				for k, v in pairs(MEM.geomancer_meta.props[val.key].tweens) do
					if val.model_data.transform_list[k] and val.model_data.transform_list[k].tween then
						local old_script = get_tween_script(val.model_data.transform_list[k].tween)
						if old_script == v.script then
							val.model_data.transform_list[k].tween = v.table
						else
							print("Meta script mismatch!")
						end
					end
				end
			end
		end
	end
	MEM.geomancer_meta = nil
end

local function import_changes()
	if not ((SET.import_level_changes and UI.tab.tab_level.state) or (SET.import_event_changes and UI.tab.tab_event.state) or
	(SET.import_beat_changes and UI.tab.tab_beat.state) or (SET.import_model_changes and UI.tab.tab_art.state)) then
		G.update_navbar("You must open a map first.", true)
		return
	else
		G.update_navbar("Importing changes", true)
	end
	local _, path, level_data, event_data, art_data, beat_data, geomancer_data
	if SET.import_changes_from_zip then
		_, path = diags.open("zip", SET.default_path_import_model_data)
		if path then
			local f = io.open(path, "rb")
			if f then
				local zip_data = f:read("*a")
				local archive = zip.open(zip_data)
				local file_index = zip.get_number_of_entries(archive) - 1
				for i = 0, file_index do
					local file = zip.extract_by_index(archive, i)
					if SET.import_event_changes and string.sub(file.name, -8) == "pw_event" then
						event_data = file.content
					elseif SET.import_level_changes and string.sub(file.name, -2) == "pw" then
						level_data = file.content
					elseif SET.import_model_changes and string.sub(file.name, -6) == "pw_art" then
						art_data = file.content
					elseif SET.import_model_changes and string.sub(file.name, -9) == "geomancer" then
						geomancer_data = file.content
					elseif SET.import_beat_changes and string.sub(file.name, -7) == "pw_beat" then
						beat_data = file.content
					end
				end
			end
		end
	else
		_, path = diags.open_folder(SET.default_path_import_model_data)
		if path then
			for filename in lfs.dir(path) do
				if not (filename == "." or filename == "..") then
					local extension = string.find(filename, "%.")
					if extension then
						extension = string.sub(filename, extension + 1)
						local function read_file(full_path)
							local f = io.open(full_path, "rb")
							if f then
								local data = f:read("*a")
								io.close(f)
								return data
							end
						end
						if SET.import_event_changes and extension == "pw_event" then
							event_data = read_file(path.."/"..filename)
						elseif SET.import_level_changes and extension == "pw" then
							level_data = read_file(path.."/"..filename)
						elseif SET.import_model_changes and extension == "pw_art" then
							art_data = read_file(path.."/"..filename)
						elseif SET.import_model_changes and extension == "geomancer" then
							geomancer_data = read_file(path.."/"..filename)
						elseif SET.import_beat_changes and extension == "pw_beat" then
							beat_data = read_file(path.."/"..filename)
						end
					end
				end
			end
		end
	end
	if UI.tab.tab_level.state and level_data then
		local level_tab = MEM.parse_json(level_data)
		if MEM.check(level_tab, "pw", "level.pw") then
			MEM.level_data.enemySet = level_tab.enemySet
			MEM.level_data.obstacleSet = level_tab.obstacleSet
			MEM.level_data.materialPropertiesSet = level_tab.materialPropertiesSet
			MEM.level_data.previewTime = level_tab.previewTime
			MEM.level_data.moveMode = level_tab.moveMode
			G.update_navbar("Level info updated")
		end
	end
	if UI.tab.tab_event.state and event_data then
		local samplesPerBeat = MEM.event_data.table.tempoSections[1].samplesPerBeat
		local beatsPerMeasure = MEM.event_data.table.tempoSections[1].beatsPerMeasure
		local startSample = MEM.event_data.table.tempoSections[1].startSample

		local event_tab = MEM.parse_json(event_data)
		if MEM.check(event_tab, "pw_event", "Selected pw_event file") then
			MEM.event_data.table = event_tab
			MEM.event_data.table.tempoSections[1].samplesPerBeat = samplesPerBeat
			MEM.event_data.table.tempoSections[1].beatsPerMeasure = beatsPerMeasure
			MEM.event_data.table.tempoSections[1].startSample = startSample
			G.update_navbar("Event data updated")
		end
	end
	if UI.tab.tab_art.state and art_data then
		local art_tab = MEM.parse_json(art_data)
		if MEM.check(art_tab, "pw_art", "Selected pw_art file") then
			local dynamic_models = {}
			if art_tab.dynamicProps then
				for key, val in ipairs(art_tab.dynamicProps) do
					dynamic_models[val.name] = true
				end
			end
			if art_tab.dynamicCullingRanges then
				for key, val in ipairs(art_tab.dynamicCullingRanges) do
					for k, v in ipairs(val.members) do
						dynamic_models[v.name] = true
					end
				end
			end
			local model_list = {}
			for key, val in ipairs(art_tab.propsDictionary) do
				model_list[val.key] = val
			end
			for key, val in ipairs(MEM.art_data.table.propsDictionary) do
				if model_list[val.key] then
					if dynamic_models[val.key] then
						val.dynamic = true
					end
					MEM.add_metadata(model_list[val.key])
					model_list[val.key].model_data.model_count = MEM.art_data.table.propsDictionary[key].model_data.model_count
					local materials_updated = false
					if not val.tween or val.tween < 1 then
						if model_list[val.key].tween > 0 then
							MEM.art_data.table.propsDictionary[key] = model_list[val.key]
							materials_updated = true
							MEM.art_data.table.propsDictionary[key].dynamic = true
						end
					end
					if not materials_updated then
						for k, v in ipairs(val.model_data.parts) do
							local new_part_tab = model_list[val.key].model_data.parts[k]
							if new_part_tab and new_part_tab.name == v.name then
								for _key in pairs(v.tab) do
									if new_part_tab.tab[_key] then
										v.tab[_key] = new_part_tab.tab[_key]
									else
										G.update_navbar("Model "..v.name.." has a wrong number of submeshes. Check if its materials ended up OK")
									end
								end
							end
						end
					end
				end
			end
		end
		if geomancer_data then
			MEM.load_geomancer_data(geomancer_data, "The geomancer metadata file")
		end
		check_geomancer_meta()
		G.update_navbar("Model data updated")
	end
	if UI.tab.tab_beat.state and beat_data then
		local beat_tab = MEM.parse_json(beat_data)
		if MEM.check(beat_tab, "pw_beat", "Selected pw_beat file") then
			local advanced_types = {Wall = true, TunnelTall = true, TunnelShort = true}
			local advanced_enemies = {FlyingBomb = true, ["Trap Enemy"] = true}
			local obstacle_count, enemy_count = 0, 0
			for key, val in ipairs(beat_tab.beatData) do
				local num_time = tonumber(val.time)
				for k, v in ipairs(val.obstacles) do
					if advanced_types[v.type] then
						for _key, list_val in ipairs(MEM.beat_data.obstacle_list) do
							local obst = MEM.beat_data.table.beatData[list_val.beat_data_key]
							local time = obst.time
							obst = obst.obstacles[list_val.obstacles_key]
							if tonumber(time) > num_time then break end
							if time == val.time and obst.placement == v.placement then
								obst.type = v.type
								obstacle_count = obstacle_count + 1
								break
							end
						end
					end
				end
				for k, v in ipairs(val.targets) do
					local change_type = advanced_enemies[v.enemyType]
					local change_sequence = advanced_sequences[v.enemySequence]
					if change_type or change_sequence then
						for _key, list_val in ipairs(MEM.beat_data.enemy_list) do
							local enemy = MEM.beat_data.table.beatData[list_val.beat_data_key]
							local time = enemy.time
							enemy = enemy.targets[list_val.enemies_key]
							if tonumber(time) > num_time then break end
							if time == val.time and enemy.placement == v.placement and enemy.distance == v.distance and
							enemy.enemyOffset == v.enemyOffset then
								if change_sequence then
									enemy.enemySequence = v.enemySequence
								end
								if change_type then
									enemy.enemyType = v.enemyType
								end
								enemy_count = enemy_count + 1
								break
							end
						end
					end
				end
			end
			local str
			if obstacle_count + enemy_count < 1 then
				str = "No changes to obstacles and enemies"
			else
				str = "Updated "
				if enemy_count > 1 then
					str = str..enemy_count.." enemies."
				elseif enemy_count > 0 then
					str = str.."one enemy"
				end
				if obstacle_count > 0 then
					if enemy_count > 0 then
						str = str.." and "
					end
					if obstacle_count > 1 then
						str = str..obstacle_count.." obstacles"
					else
						str = str.."one obstacle"
					end
				end
			end
			G.update_navbar(str)
		end
	end
end

local function cleanup_after_loading_files()
	MEM.setup_culling_ranges()
	COL.setup_colours()

	check_geomancer_meta()

	if MEM.level_data.sceneDisplayName then
		G.update_navbar("Loaded scene: "..MEM.level_data.sceneDisplayName)
		if MEM.level_data.mapper == "Klear" or MEM.level_data.mapper == "Klear_" or MEM.level_data.mapper == "kingklear" then
			G.update_navbar("Hey, that's one of mine! Hope you like it")
		end
	else
		G.update_navbar("Unknown scene name")
	end
	if UI.tab.tab_event.state then
		msg.post("/event#tab_event", hash("detect_sample_rate"))
	end
	msg.post("/navbar#navbar", hash("update_tabs"))

	check_for_reset()
end

local function load_data(expected_filename, extension, file_list)
	if expected_filename then
		if file_list[expected_filename] then
			local panel = MEM.load_file(file_list[expected_filename].path, expected_filename, file_list[expected_filename].extension, file_list[expected_filename].content)
			if panel then
				G.update_navbar(expected_filename.." loaded.")
			end
			return true
		end
	end
	for filename, tab in pairs(file_list) do
		if tab.extension == extension then
			local panel = MEM.load_file(tab.path, filename, extension, tab.content)
			if panel then
				G.update_navbar(filename.." loaded.")
			end
			return true
		end
	end
	if extension == "ogg" then
		if MEM.level_data.remixTarget then
			G.update_navbar("Map uses built-in music. Preview will be unavailable.")
			return false
		else
			G.update_navbar("Music file not found.")
		end
	elseif extension == "png" then
		G.update_navbar("Poster not found.") -- Placeholder \""..archive_name..".png\" added.")
		return false
	elseif extension == "geomancer" then
		return false
	else
		G.update_navbar(extension.." file not found.")
	end
end

local function load_zip(path)
	SND.stop_music()
	local f = io.open(path, "rb")
	if f then
		G.update_navbar("Extracting files from "..path, true)
		local zip_data = f:read("*a")
		local archive = zip.open(zip_data)
		local htap = string.reverse(path)
		local archive_name = string.reverse(string.sub(htap, string.find(htap, "%.") + 1, string.find(htap, "\\") - 1))

		if not archive then
			G.update_navbar("Error extracting files. Try resaving the map with the current Pistol Mix version or extract the files manually.")
			return
		end
		local loaded_count, expected_count = 0, 10
		local file_index = zip.get_number_of_entries(archive)
		if file_index < 0 then
			G.update_navbar("Archive is empty.")
			return
		end
		local extracted_files = {}
		for i = 1, file_index do
			local err, file = pcall(zip.extract_by_index, archive, i - 1)
			if not err then
				G.update_navbar("Error extracting files. Try resaving the map with the current Pistol Mix version or extract the files manually.")
				return
			end
			if file then
				local emanelif = string.reverse(file.name)
				local extension_index = string.find(emanelif, "%.")
				if extension_index then
					local extension = string.reverse(string.sub(emanelif, 1, extension_index - 1))
					if not file.content then
						G.update_navbar("Error extracting "..file.name.." The archive might be corrupted.")
					else
						extracted_files[file.name] = {extension = extension, content = file.content}
					end
				end
			else
				G.update_navbar("Error extracting one of the files. Skipping.")
			end
		end
		local filename_ogg, filename_sequence, filename_art, filename_poster
		if extracted_files["level.pw"] then
			local panel = MEM.load_file(nil, "level.pw", "pw", extracted_files["level.pw"].content) 
			if panel then
				G.update_navbar("Level data loaded.")
				if not MEM.level_data.remixTarget then
					filename_ogg = MEM.level_data.songLocation
				end
				filename_sequence = MEM.level_data.sequenceDictionary
				filename_art = MEM.level_data.sharedLevelArt
				filename_poster = MEM.level_data.art
				loaded_count = loaded_count + 1
			end
		else
			G.update_navbar("level.pw not found")
		end

		local function get_file_count(expected_filename, extension, file_list)
			local result = load_data(expected_filename, extension, file_list)
			if result then
				loaded_count = loaded_count + 1
			elseif result == false then
				expected_count = expected_count - 1
			end
		end

		get_file_count(filename_art, "pw_art", extracted_files)
		get_file_count(filename_ogg, "ogg", extracted_files)
		get_file_count(filename_sequence, "pw_seq", extracted_files)
		get_file_count(filename_poster, "png", extracted_files)
		get_file_count("do_not_ship", "pw_meta", extracted_files)
		get_file_count(archive_name..".pw_beat", "pw_beat", extracted_files)
		get_file_count(archive_name..".pw_event", "pw_event", extracted_files)
		get_file_count(archive_name..".pw_geo", "pw_geo", extracted_files)
		get_file_count(archive_name..".geomancer", "geomancer", extracted_files)
		zip.close(archive)

		if loaded_count < expected_count then
			G.update_navbar("Loaded "..loaded_count.." files.")
		else
			G.update_navbar("Loaded "..loaded_count.." files. Export should produce a working map.")
		end

		cleanup_after_loading_files()
	end
end

local function load_file(path)
	local htap = string.reverse(path)
	local filename = string.reverse(string.sub(htap, 1, string.find(htap, "\\") - 1))
	local extension = string.find(htap, "%.")
	extension = string.reverse(string.sub(htap, 1, extension - 1))
	if extension == "ogg" then
		SND.stop_music()
	end
	G.update_navbar("Loading "..filename, true)
	timer.delay(0.01, false, function()
		local panel = MEM.load_file(path, filename, extension)
		if panel then
			G.update_navbar("File loaded successfully")
			msg.post("/navbar#navbar", hash("update_tabs"))
			check_for_reset()
			if extension == "pw_event" then
				msg.post("/event#tab_event", hash("detect_sample_rate"))
			elseif extension == "pw_art" then
				MEM.setup_culling_ranges()
				COL.setup_colours()
			end
		else
			G.update_navbar("File not loaded")
		end
	end)
end

local function load_dir(path)
	SND.stop_music()
	G.update_navbar("Loading files from "..path, true)
	local file_list = {}
	local ext_list = {pw_meta = true, pw = true, pw_beat = true, pw_event = true, pw_geo = true, pw_art = true, pw_seq = true, geomancer = true, ogg = true, png = true}
	for filename in lfs.dir(path) do
		if not (filename == "." or filename == "..") then
			local extension_pos = string.find(filename, "%.")
			if extension_pos then
				local extension = string.sub(filename, extension_pos + 1)
				if ext_list[extension] then
					file_list[filename] = {path = path.."/"..filename, extension = extension}
				end
			end
		end
	end

	if next(file_list) then
		local loaded_count, expected_count = 0, 10
		local filename_ogg, filename_sequence, filename_art, filename_poster, common_name
		if file_list["level.pw"] then
			local panel = MEM.load_file(file_list["level.pw"].path, "level.pw", "pw") 
			if panel then
				G.update_navbar("Level data loaded.")
				if not MEM.level_data.remixTarget then
					filename_ogg = MEM.level_data.songLocation
				end
				filename_sequence = MEM.level_data.sequenceDictionary
				filename_art = MEM.level_data.sharedLevelArt
				filename_poster = MEM.level_data.art
				loaded_count = loaded_count + 1
				if filename_art then
					local ext = string.find(filename_art, "%.")
					common_name = string.sub(filename_art, 1, ext - 11)
				end
			end
		end
		
		local function get_file_count(expected_filename, extension, _file_list)
			local result = load_data(expected_filename, extension, _file_list)
			if result then
				loaded_count = loaded_count + 1
			elseif result == false then
				expected_count = expected_count - 1
			end
		end

		get_file_count(filename_art, "pw_art", file_list)
		get_file_count(filename_ogg, "ogg", file_list)
		get_file_count(filename_sequence, "pw_seq", file_list)
		get_file_count(filename_poster, "png", file_list)
		get_file_count("do_not_ship", "pw_meta", file_list)
		get_file_count(common_name..".pw_beat", "pw_beat", file_list)
		get_file_count(common_name..".pw_event", "pw_event", file_list)
		get_file_count(common_name..".pw_geo", "pw_geo", file_list)
		get_file_count(common_name..".geomancer", "geomancer", file_list)

		if loaded_count < expected_count then
			G.update_navbar("Loaded "..loaded_count.." files.")
		else
			G.update_navbar("Loaded "..loaded_count.." files. Export should produce a working map.")
		end
		cleanup_after_loading_files()
	else
		G.update_navbar("No valid files found.")
	end
end

local function unload_all()
	for key, val in pairs(UI.tab) do
		if not (val.state == nil) then
			val.state = false
		end
	end
	UI.tab.tab_options.state = true
	UI.tab.tab_rotate.state = true
	UI.tab.tab_file.state = true
	MEM.level_data = {}
	MEM.meta_data = {}
	MEM.beat_data = {}
	MEM.event_data = {}
	MEM.geo_data = {}
	MEM.sequence_data = {}
	MEM.art_data = {}
	MOD.release_model_resources()
	SND.unload_music()
	MEM.music = nil
	MEM.music_raw = nil
	MEM.poster = nil
	msg.post("/event#tab_event", hash("reset"))
	msg.post("/navbar#navbar", hash("update_tabs"))
end

local function evaluate_button(button)
	if button == "exit" then
		os.exit(1)
	elseif button == "klear_button" then

	elseif button == "map_preview" then
		if MEM.art_data.table then
			G.update_navbar("", true)
			msg.post("#", hash("disable"))
			msg.post("#", hash("release_input_focus"))
			msg.post("/model_viewer", hash("tween_preview"), {preview_map = true})
		else
			G.update_navbar("Map data not loaded", true)
		end
	elseif button == "help" then
		sys.open_url("https://mod.io/g/pistol-whip/r/geomancer")
	elseif button == "import_checkbox" then
		SET.import_changes_from_zip = not SET.import_changes_from_zip
		set_checkbox("import_checkbox", SET.import_changes_from_zip)
	elseif button == "export_folder_checkbox" then
		SET.create_folder_on_export = not SET.create_folder_on_export
		set_checkbox("export_folder_checkbox", SET.create_folder_on_export)
	elseif button == "import_level" then
		SET.import_level_changes = not SET.import_level_changes
		set_checkbox("import_level", SET.import_level_changes)
	elseif button == "import_events" then
		SET.import_event_changes = not SET.import_event_changes
		set_checkbox("import_events", SET.import_event_changes)
	elseif button == "import_models" then
		SET.import_model_changes = not SET.import_model_changes
		set_checkbox("import_models", SET.import_model_changes)
	elseif button == "import_beat" then
		SET.import_beat_changes = not SET.import_beat_changes
		set_checkbox("import_beat", SET.import_beat_changes)
	elseif button == "import_changes" then
		import_changes()
	elseif button == "degeomance" then
		if SET.confirm_degeomance then
			DIALOG.open(TAB_NAME, "dialog_confirm", {title = "Are you sure you want to remove all Geomancer changes from the loaded map?", button_1 = "Degeomance", button_3 = "Cancel", subject = "degeomance_confirm"})
		else
			degeomance()
		end
	elseif button == "load_file" then
		local num, path = diags.open("pw_meta,pw,pw_beat,pw_event,pw_geo,pw_art,pw_seq", SET.default_path_load_file)
		if path then
			load_file(path)
		end
	elseif button == "load_zip" then
		local _, path = diags.open("zip", SET.default_path_load_zip)
		if path then
			if SET.unload_data_before_loading_zip then
				unload_all()
			end
			timer.delay(0.01, false, function()
				load_zip(path)
			end)
		end
	elseif button == "load_dir" then
		local num, path = diags.open_folder(SET.default_path_load_directory)
		if path then
			if SET.unload_data_before_loading_folder then
				unload_all()
			end
			timer.delay(0.01, false, function()
				load_dir(path)
			end)
		end
	elseif button == "unload_all" then
		unload_all()
		G.update_navbar("All data unloaded.", true)
	elseif button == "export_all" then
		export_all(not SET.create_folder_on_export)
	end
end

function on_input(self, action_id, action)
	UI.on_input(TAB_NAME, action_id, action, evaluate_button)
end