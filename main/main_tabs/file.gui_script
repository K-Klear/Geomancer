local UI = require "modules.ui"
local MEM = require "modules.memory"
local G = require "modules.global"
local SET = require "modules.settings"
local DIALOG = UI.DIALOG
local TAB_NAME = "tab_file"

local files_to_export

local function set_checkbox(checkbox, value)
	if value then
		gui.set_text(gui.get_node(checkbox.."/text"), "X")
	else
		gui.set_text(gui.get_node(checkbox.."/text"), "")
	end
end

function init(self)
	gui.set_render_order(1)
	gui.set_text(gui.get_node("version_label"), "Version "..sys.get_config("project.version"))
	UI.load_template({"exit", "load_dir", "load_file", "load_zip", "unload_all", "export_all", "export_folder_checkbox", "import_changes",
	"import_checkbox", "degeomance", "import_level", "import_events", "import_beat", "import_models", "help", "klear_button"}, TAB_NAME)
	if SET.I_am_Klear then
		UI.load_template("klear_button", TAB_NAME)
	else
		gui.set_enabled(gui.get_node("klear_button/button_white"), false)
	end
	set_checkbox("import_checkbox", SET.import_changes_from_zip)
	set_checkbox("export_folder_checkbox", SET.create_folder_on_export)
	set_checkbox("import_level", SET.import_level_changes)
	set_checkbox("import_events", SET.import_event_changes)
	set_checkbox("import_beat", SET.import_beat_changes)
	set_checkbox("import_models", SET.import_model_changes)
end

local function run_export_fn()
	for key, val in ipairs(files_to_export) do
		val.fn(val.path)
		msg.post("/navbar#navbar", hash("update_status"), {text = val.text})
	end
	msg.post("/navbar#navbar", hash("update_status"), {text = "Files exported"})
	files_to_export = nil
end

local function check_for_reset()
	if MEM.event_reloaded then
		MEM.event_reloaded = nil
	end
	if MEM.art_reloaded then
		msg.post("/art#tab_art", hash("reset"))
		MEM.art_reloaded = nil
	end
	if MEM.beat_reloaded then
		msg.post("/beat#tab_beat", hash("reset"))
		MEM.beat_reloaded = nil
	end
	if MEM.slices_reloaded then
		msg.post("/meta#tab_meta", hash("reset"))
		MEM.slices_reloaded = nil
	end
end

local function export_level(path)
	local f = G.safe_output(path)
	if f then
		MEM.export_json(MEM.level_data)
		io.close(f)
	end
end

local function export_event(path)
	local f = G.safe_output(path)
	if f then
		MEM.export_json(MEM.event_data.table)
		io.close(f)
	end
end

local function get_tween_script(tween_data, model_name)
	if not tween_data then return end
	local str = ""
	local deletion_count, save_original
	tween_data, deletion_count, save_original = G.expand_repeat_actions(tween_data)
	if model_name then
		if deletion_count > 1 then
			G.update_navbar(deletion_count.." invalid repeat actions have been removed from tween of "..model_name)
		elseif deletion_count > 0 then
			G.update_navbar("An invalid repeat action has been removed from tween of "..model_name)
		end
	end

	for key, val in ipairs(tween_data) do
		if val.type == "W" then
			str = str..val.type..val.time..";"
		else
			if val.easing then
				local node_values = G.separate_easing(val)
				for k, v in ipairs(node_values) do
					str = str..val.type..val.part..";"..v.s.x..","..v.s.y..","..v.s.z..";"..v.e.x..","..v.e.y..","..v.e.z..";"..v.t..";"
				end
			else
				str = str..val.type..val.part..";"..val.start_state.x..","..val.start_state.y..","
				str = str..val.start_state.z..";"..val.end_state.x..","..val.end_state.y..","..val.end_state.z..";"..val.time..";"
			end
		end
	end
	return str, save_original
end

local function export_art(path)
	-- put the geomancer meta file creation stuff here somewhere
	local is_dynamic = {}
	local model_table = MEM.art_data.table
	for key, val in ipairs(model_table.propsDictionary) do
		for k, v in ipairs(val.model_data.transform_list) do
			for i = #v.tab.components, 1, -1 do
				if (v.tab.components[i].type == "ScriptedTween") or (v.tab.components[i].type == "LevelEventReceiver") then
					table.remove(v.tab.components, i)
				end
			end
			if v.tween then
				local tween_script, save_original = get_tween_script(v.tween, val.key)
				if tween_script then
					table.insert(v.tab.components, {type = "ScriptedTween", Script = tween_script, _key_sort = {"type", "Script"}})
					table.insert(v.tab.components, {type = "LevelEventReceiver", EventId = v.tween.signal,
					ActionType = "ScriptedTweenTrigger", _key_sort = {"type", "EventId", "ActionType"}})
					if save_original then
						MEM.geomancer_meta.props[val.key] = MEM.geomancer_meta.props[val.key] or {tweens = {}}
						MEM.geomancer_meta.props[val.key].tweens[k] = {table = v.tween, script = tween_script, signal = v.tween.signal}
						MEM.geomancer_meta.props[val.key].tweens[k].table.signal = nil
					end
				end
			end
		end
		is_dynamic[val.key] = val.dynamic
	end
	table.insert(model_table.propsDictionary, 1, MEM.art_data.placeholder)
	model_table.staticProps = model_table.staticProps or {}
	model_table.dynamicProps = model_table.dynamicProps or {}
	model_table.staticCullingRanges = model_table.staticCullingRanges or {}
	model_table.dynamicCullingRanges = model_table.dynamicCullingRanges or {}
	for i = #model_table.staticProps, 1, -1 do
		if is_dynamic[model_table.staticProps[i].name] then
			table.insert(model_table.dynamicProps, table.remove(model_table.staticProps, i))
		end
	end
	for i = #model_table.dynamicProps, 1, -1 do
		if not is_dynamic[model_table.dynamicProps[i].name] then
			table.insert(model_table.staticProps, table.remove(model_table.dynamicProps, i))
		end
	end
	local moved_static_ranges, moved_dynamic_ranges = {}, {}
	for i = #model_table.staticCullingRanges, 1, -1 do
		local range = model_table.staticCullingRanges[i]
		for j = #range.members, 1, -1 do
			if is_dynamic[range.members[j].name] then
				moved_static_ranges[range.range] = moved_static_ranges[range.range] or {}
				table.insert(moved_static_ranges[range.range], table.remove(range.members, j))
			end
		end
		if #range.members < 1 then
			table.remove(model_table.staticCullingRanges, i)
		end
	end
	for i = #model_table.dynamicCullingRanges, 1, -1 do
		local range = model_table.dynamicCullingRanges[i]
		for j = #range.members, 1, -1 do
			if not is_dynamic[range.members[j].name] then
				moved_dynamic_ranges[range.range] = moved_dynamic_ranges[range.range] or {}
				table.insert(moved_dynamic_ranges[range.range], table.remove(range.members, j))
			end
		end
		if #range.members < 1 then
			table.remove(model_table.dynamicCullingRanges, i)
		end
	end
	for key, val in ipairs(model_table.staticCullingRanges) do
		if moved_dynamic_ranges[val.range] then
			for k, v in ipairs(moved_dynamic_ranges[val.range]) do
				table.insert(val.members, v)
			end
			moved_dynamic_ranges[val.range] = nil
		end
	end
	for key, val in pairs(moved_dynamic_ranges) do
		table.insert(model_table.staticCullingRanges, {range = key, members = val, _key_sort = {"members", "range"}})
	end

	for key, val in ipairs(model_table.dynamicCullingRanges) do
		if moved_static_ranges[val.range] then
			for k, v in ipairs(moved_static_ranges[val.range]) do
				table.insert(val.members, v)
			end
			moved_static_ranges[val.range] = nil
		end
	end
	for key, val in pairs(moved_static_ranges) do
		table.insert(model_table.dynamicCullingRanges, {range = key, members = val, _key_sort = {"members", "range"}})
	end

	local function range_to_number(range_str)
		local comma = string.find(range_str, ",")
		local first = tonumber(string.sub(range_str, 1, comma - 1))
		local second = tonumber(string.sub(range_str, comma +1))
		return first + (second * 0.001)
	end

	table.sort(model_table.staticCullingRanges, function(a, b) return range_to_number(a.range) < range_to_number(b.range) end)
	table.sort(model_table.dynamicCullingRanges, function(a, b) return range_to_number(a.range) < range_to_number(b.range) end)
	
	if #model_table.dynamicProps < 0 then
		model_table.dynamicProps = nil
	end
	if #model_table.dynamicCullingRanges < 0 then
		model_table.dynamicCullingRanges = nil
	end

	local key_sort_list = {staticProps = true, dynamicProps = true, staticCullingRanges = true, dynamicCullingRanges = true}

	local colour_index
	for i = #model_table._key_sort, 1, -1 do
		if key_sort_list[model_table._key_sort[i]] then
			table.remove(model_table._key_sort, i)
		end
		if model_table._key_sort[i] == "colors" then
			colour_index = i + 1
		end
	end

	if model_table.dynamicCullingRanges then
		table.insert(model_table._key_sort, colour_index, "dynamicCullingRanges")
	end
	if model_table.dynamicProps then
		table.insert(model_table._key_sort, colour_index, "dynamicProps")
	end
	table.insert(model_table._key_sort, colour_index, "staticCullingRanges")
	table.insert(model_table._key_sort, colour_index, "staticProps")
	
	local f = G.safe_output(path)
	if f then
		MEM.export_json(MEM.art_data.table)
		io.close(f)
	end

	table.remove(model_table.propsDictionary, 1)
	model_table.staticProps = model_table.staticProps or {}
	model_table.dynamicProps = model_table.dynamicProps or {}
	model_table.staticCullingRanges = model_table.staticCullingRanges or {}
	model_table.dynamicCullingRanges = model_table.dynamicCullingRanges or {}
end

local function export_beat(path)
	local f = G.safe_output(path)
	if f then
		MEM.export_json(MEM.beat_data.table)
		io.close(f)
	end
end

local function export_geo(path)
	local f = G.safe_output(path)
	if f then
		MEM.export_json(MEM.geo_data.table)
		io.close(f)
	end
end

local function export_slice(path)
	local output_string = ""
	if #MEM.meta_data.volumes < 1 then
		output_string = MEM.meta_data.string_start..MEM.meta_data.string_end
	else
		if #MEM.meta_data.volume_table > 0 then
			output_string = ","
		end
		for key, val in ipairs(MEM.meta_data.volumes) do
			output_string = output_string..val
			if key < #MEM.meta_data.volumes then
				output_string = output_string..","
			end
		end
		output_string = MEM.meta_data.string_start..output_string..MEM.meta_data.string_end
	end

	if not G.safe_decode(output_string, "do_not_ship.pw_meta") then
		msg.post("/navbar#navbar", hash("update_status"), {text = "Meta data might be corrupted. Use with caution."})
	end

	local f = G.safe_output(path)
	if f then
		io.write(output_string)
		io.close(f)
	end
end

local function export_geomancer_meta(path)
	local f = G.safe_output(path)
	if f then
		io.write(json.encode(MEM.geomancer_meta))
		io.close(f)
	end
	for key, val in pairs(MEM.geomancer_meta.props) do
		if val.tweens then
			for k, v in pairs(val.tweens) do
				v.table.signal = v.signal
			end
		end
	end
	MEM.geomancer_meta = nil
end

local function export_all(overwrite)
	if UI.tab.tab_level.state or UI.tab.tab_event.state or UI.tab.tab_geo.state or UI.tab.tab_beat.state or UI.tab.tab_meta.state or UI.tab.tab_art.state then
		local num, path
		if overwrite then
			num, path = diags.open_folder(SET.default_path_export)
		else
			num, path = diags.open_folder(SET.default_path_export_overwrite)
		end
		if path then
			local filenames = {}
			local common_filename = "map"
			local function get_name(s)
				if s then
					local ext = string.find(s, "%.")
					return string.sub(s, 1, ext - 1)
				end
			end
			local function get_art_name(s)
				if s then
					local shared = string.find(MEM.art_data.filename, "_SharedArt") or -7 -- In case _SharedArt not found in filename just remove the extension
					return string.sub(MEM.art_data.filename, 1, shared - 1)
				end
			end
			filenames.beat = get_name(MEM.beat_data.filename)
			filenames.event = get_name(MEM.event_data.filename)
			filenames.geo = get_name(MEM.geo_data.filename)
			filenames.art = get_art_name(MEM.art_data.filename)
			if next(filenames) then
				common_filename = filenames[next(filenames)]
				for key, val in pairs(filenames) do
					if not (val == common_filename) then
						common_filename = get_art_name(MEM.level_data.sharedLevelArt) or filenames.art or filenames.event or filenames.beat or filenames.geo
						break
					end
				end
			end
			MEM.geomancer_meta = {version = sys.get_config("project.version"), props = {}}
			if not overwrite then
				path = path.."\\"..common_filename.."_geomanced"
				if not lfs.mkdir(path) then
					local index = 0
					repeat
						index = index + 1
						if index > 1000 then
							G.update_navbar("Cannot create folder. Export aborted")
							return
						end
					until lfs.mkdir(path.."("..index..")")
					path = path.."("..index..")"
				end
				G.update_navbar("Exporting files to "..path, true)
				if next(MEM.level_data) then
					export_level(path.."\\level.pw")
					G.update_navbar("Level settings exported")
				end
				if MEM.event_data.table then
					export_event(path.."\\"..common_filename..".pw_event")
					G.update_navbar("Events exported")
				end
				if MEM.art_data.table then
					export_art(path.."\\"..common_filename.."_SharedArt.pw_art")
					G.update_navbar("Model data exported")
				end
				if MEM.beat_data.table then
					export_beat(path.."\\"..common_filename..".pw_beat")
					G.update_navbar("Enemies exported")
				end
				if MEM.geo_data.table then
					export_geo(path.."\\"..common_filename..".pw_geo")
					G.update_navbar("Geo exported")
				end
				if MEM.meta_data.table then
					export_slice(path.."\\do_not_ship.pw_meta")
				end

				export_geomancer_meta(path.."\\"..common_filename..".geomancer")
				
				G.update_navbar("Files exported to "..path)
			else
				G.update_navbar("Starting export", true)
				files_to_export = {}
				local full_path
				if next(MEM.level_data) then
					full_path = path.."\\level.pw"
					table.insert(files_to_export, {fn = export_level, path = full_path, exists = sys.exists(full_path), text = "Level settings exported"})
				end
				if MEM.event_data.table then
					full_path = path.."\\"..common_filename..".pw_event"
					table.insert(files_to_export, {fn = export_event, path = full_path, exists = sys.exists(full_path), text = "Events exported"})
				end
				if MEM.art_data.table then
					full_path = path.."\\"..common_filename.."_SharedArt.pw_art"
					table.insert(files_to_export, {fn = export_art, path = full_path, exists = sys.exists(full_path), text = "Model data exported"})
				end
				if MEM.beat_data.table then
					full_path = path.."\\"..common_filename..".pw_beat"
					table.insert(files_to_export, {fn = export_beat, path = full_path, exists = sys.exists(full_path), text = "Enemies exported"})
				end
				if MEM.geo_data.table then
					full_path = path.."\\"..common_filename..".pw_geo"
					table.insert(files_to_export, {fn = export_geo, path = full_path, exists = sys.exists(full_path), text = "Geo exported"})
				end
				if MEM.meta_data.table then
					full_path = path.."\\do_not_ship.pw_meta"
					local text
					if #MEM.meta_data.volumes > 0 then
						text = "Volumes exported. NOTE: this does nothing until you open the map in Pistol Mix and generate geo."
					else
						text = "do_not_ship.pw_meta exported."
					end
					table.insert(files_to_export, {fn = export_slice, path = full_path, exists = sys.exists(full_path), text = text})
				end

				full_path = path.."\\"..common_filename..".geomancer"
				table.insert(files_to_export, {fn = export_geomancer_meta, path = full_path, exists = sys.exists(full_path), text = "Geomancer metadata exported"})
				
				local overwrite_count = 0
				for key, val in ipairs(files_to_export) do
					if val.exists then
						overwrite_count = overwrite_count + 1
					end
				end
				if overwrite_count < 1 then
					run_export_fn()
				elseif not SET.confirm_file_overwrite then
					G.update_navbar("Exporting files to "..path.."\nEXISTING FILES ARE BEING OVERWRITTEN", true)
					run_export_fn()
				else
					local title = overwrite_count.." files will be overwritten. Continue with export?"
					DIALOG.open(TAB_NAME, "dialog_confirm", {title = title, button_1 = "Overwrite", button_3 = "Cancel", subject = "overwrite_export"})
				end
			end
		end
	else
		G.update_navbar("Nothing to export", true)
	end
end

local advanced_sequences = 	{
	__Flying_ATTACK = true,
	["Zig_shoot _Zag_shoot"] = true,
	Strafe_shoot_retreat = true,
	FWD_RGHT_FWD_SHT = true,
	["STRAFE SHOOT x3"] = true,
	--		High_FlyingSkull Basic = true,
	--		ONBEAT_High_FlyingSkull = true,
	--		FlyingSkull Basic = true,
	--		FlyingSkull Short
	--		DefaultEnemySequence_Jetpack = true,
	BeatSpawn_Jetpack_Stationary = true,
	["_Run Roll Shoot"] = true,
	--		__SniperJoeTest = true,
	--		ImmediateDespawn = true,
	CrookedTestSequence = true,
	["EmptyEnemySequence 1"] = true,
	Run_Slide_Shoot_01 = true,
	_VaultShoot_01 = true,
	ENME_SEQ_06 = true,
	ENME_SEQ_07 = true,
	StrafeRightLeft = true,
	Canter_Forward_Shoot = true,
	TestEnemySequence = true
}

local function degeomance()
	if not (UI.tab.tab_level.state or UI.tab.tab_event.state or UI.tab.tab_beat.state or UI.tab.tab_art.state or UI.tab.tab_meta.state) then
		G.update_navbar("You must open a map first.", true)
		return
	end
	G.update_navbar("De-geomancing map", true)
	if UI.tab.tab_level.state then
		local change = false
		if not (MEM.level_data.previewTime == 0) then
			MEM.level_data.previewTime = 0
			G.update_navbar("Preview time reset to 0")
			change = true
		end
		if not (MEM.level_data.moveMode == "Moving") then
			MEM.level_data.moveMode = "Moving"
			G.update_navbar("Move mode set to Moving")
			change = true
		end
		if not change then
			G.update_navbar("No level info changes necessary")
		end
	end
	if UI.tab.tab_event.state then
		local nobeat_count = #MEM.event_data.table.eventsData[MEM.event_data.nobeat_track_index].events
		local event_count = #MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events
		local tempo_count = #MEM.event_data.table.tempoSections
		MEM.event_data.table.eventsData[MEM.event_data.nobeat_track_index].events = {}
		local skipped_count = 0
		if not MEM.level_data.obstacleSet then
			for key = event_count, 1, -1 do
				local payload = MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events[key].payload
				if (payload == "PillarDrop") or (payload == "RisePillar") then
					event_count = event_count - 1
				else
					table.remove(MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events, key)
				end
			end
		elseif MEM.level_data.obstacleSet == "AirDrop" then
			for key = event_count, 1, -1 do
				local payload = MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events[key].payload
				if payload == "PillarDrop" then
					event_count = event_count - 1
					skipped_count = skipped_count + 1
				else
					table.remove(MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events, key)
				end
			end
			if MEM.beat_data.obstacle_list then
				if skipped_count < #MEM.beat_data.obstacle_list then
					local new_event_count = #MEM.beat_data.obstacle_list - skipped_count
					for i = 1, new_event_count do
						msg.post(UI.tab.tab_event.path, hash("add_event"), {start_sample = i, signal = "PillarDrop"})
					end
					if new_event_count > 1 then
						G.update_navbar("Created "..new_event_count.." PillarDrop events at the start of the map.")
					else
						G.update_navbar("Created a PillarDrop event at the start of the map.")
					end
				end
			end
		elseif MEM.level_data.obstacleSet == "Spooky" then
			for key = event_count, 1, -1 do
				local payload = MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events[key].payload
				if payload == "RisePillar" then
					event_count = event_count - 1
					skipped_count = skipped_count + 1
				else
					table.remove(MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events, key)
				end
			end
			if MEM.beat_data.obstacle_list then
				if skipped_count < #MEM.beat_data.obstacle_list then
					local new_event_count = #MEM.beat_data.obstacle_list - skipped_count
					for i = 1, new_event_count do
						msg.post(UI.tab.tab_event.path, hash("add_event"), {start_sample = i, signal = "RisePillar"})
					end
					if new_event_count > 1 then
						G.update_navbar("Created "..new_event_count.." RisePillar events at the start of the map.")
					else
						G.update_navbar("Created a RisePillar event at the start of the map.")
					end
				end
			end
		else
			MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events = {}
		end


		if #MEM.event_data.table.tempoSections > 1 then
			MEM.event_data.table.tempoSections = {MEM.event_data.table.tempoSections[1]}
		end
		local change = false
		if nobeat_count > 1 then
			G.update_navbar("Removed "..nobeat_count.." no-beat sections")
			change = true
		elseif nobeat_count > 0 then
			G.update_navbar("Removed one no-beat section")
			change = true
		end
		if event_count > 1 then
			G.update_navbar("Removed "..event_count.." event triggers")
			change = true
		elseif event_count > 0 then
			G.update_navbar("Removed one event trigger")
			change = true
		end
		if tempo_count > 2 then
			G.update_navbar("Removed "..(tempo_count - 1).." tempo sections")
			change = true
		elseif tempo_count > 1 then
			G.update_navbar("Removed one tempo section")
			change = true
		end
		if not change then
			G.update_navbar("No event file changes necessary")
		end
	end
	if UI.tab.tab_art.state then
		msg.post("/art#tab_art", hash("degeomance"))
	end
	if UI.tab.tab_beat.state then
		local obstacle_count, enemy_type_count, sequence_count = 0, 0, 0
		local obstacle_types = {Wall = "Sidestep", TunnelTall = "LimboTall", TunnelShort = "LimboShort"}
		for key, val in ipairs(MEM.beat_data.obstacle_list) do
			local obstacle_data = MEM.beat_data.table.beatData[val.beat_data_key].obstacles[val.obstacles_key]
			if obstacle_types[obstacle_data.type] then
				obstacle_count = obstacle_count + 1
				obstacle_data.type = obstacle_types[obstacle_data.type]
			end
		end

		local enemy_names = {
			Normal = "normal",
			Tough = "tough",
			ChuckNorris = "chuck",
			["Mounted Enemy"] = "horse",
			Shield = "shield",
			["Normal Turret"] = "turret",
			["Minigun Turret"] = "minigun",
			FlyingBomb = "skull",
			["Trap Enemy"] = "trap"
		}

		for key, val in ipairs(MEM.beat_data.enemy_list) do
			local enemy_data = MEM.beat_data.table.beatData[val.beat_data_key].targets[val.enemies_key]
			if enemy_data.enemyType == "FlyingBomb" then
				enemy_data.enemyType = SET.degeomance_skull
				MEM.beat_data.enemy_types[enemy_names[SET.degeomance_skull]] = true
				enemy_type_count = enemy_type_count + 1
			elseif val.type == "Trap Enemy" then
				enemy_data.enemyType = SET.degeomance_glitched_enemy
				MEM.beat_data.enemy_types[enemy_names[SET.degeomance_glitched_enemy]] = true
			end
			if advanced_sequences[enemy_data.enemySequence] then
				enemy_data.enemySequence = SET.degeomance_sequence
				sequence_count = sequence_count + 1
			end
			MEM.beat_data.enemy_types.FlyingBomb = false
			MEM.beat_data.enemy_types["Trap Enemy"] = false
		end
		if obstacle_count > 1 then
			G.update_navbar("Changed "..obstacle_count.." obstacles")
		elseif obstacle_count > 0 then
			G.update_navbar("Changed one obstacle")
		end
		if enemy_type_count > 1 then
			G.update_navbar("Changed "..enemy_type_count.." enemy types")
		elseif enemy_type_count > 0 then
			G.update_navbar("Changed one enemy type")
		end
		if sequence_count > 1 then
			G.update_navbar("Changed "..sequence_count.." sequences")
		elseif sequence_count > 0 then
			G.update_navbar("Changed one sequence")
		end
	end
	if UI.tab.tab_meta.state then

	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("hide") then
		msg.post("#", hash("disable"))
		msg.post("#", hash("release_input_focus"))
		DIALOG.close_all(TAB_NAME)
	elseif message_id == hash("show") then
		msg.post("#", hash("enable"))
		msg.post("#", hash("acquire_input_focus"))
	elseif message_id == hash("export_all") then
		export_all(not SET.create_folder_on_export)
	elseif message_id == hash("dialog_closed") then
		msg.post("#", hash("acquire_input_focus"))
		if message.dialog == "dialog_confirm" then
			if message.subject == "overwrite_export" then
				if message.button == 1 then 			-- buttons are 1 = overwrite, 3 = cancel
					run_export_fn()
				else
					files_to_export = nil
					msg.post("/navbar#navbar", hash("update_status"), {text = "Export aborted", clear = true})
				end
			elseif message.subject == "degeomance_confirm" then
				if message.button == 1 then
					degeomance()
				end
			end
		end
	end
end

local function check_geomancer_meta()
	if MEM.art_data.table and MEM.geomancer_meta and MEM.geomancer_meta.props and next(MEM.geomancer_meta.props) then
		for key, val in ipairs(MEM.art_data.table.propsDictionary) do
			if MEM.geomancer_meta.props[val.key] then
				for k, v in pairs(MEM.geomancer_meta.props[val.key].tweens) do
					if val.model_data.transform_list[k] and val.model_data.transform_list[k].tween then
						local old_script = get_tween_script(val.model_data.transform_list[k].tween)
						if old_script == v.script then
							val.model_data.transform_list[k].tween = v.table
						end
					end
				end
			end
		end
	end
	MEM.geomancer_meta = nil
end

local function import_changes()
	if not ((SET.import_level_changes and UI.tab.tab_level.state) or (SET.import_event_changes and UI.tab.tab_event.state) or
	(SET.import_beat_changes and UI.tab.tab_beat.state) or (SET.import_model_changes and UI.tab.tab_art.state)) then
		G.update_navbar("You must open a map first.", true)
		return
	else
		G.update_navbar("Importing changes", true)
	end
	local _, path, level_data, event_data, art_data, beat_data, geomancer_data
	if SET.import_changes_from_zip then
		_, path = diags.open("zip", SET.default_path_import_model_data)
		if path then
			local f = io.open(path, "rb")
			if f then
				local zip_data = f:read("*a")
				local archive = zip.open(zip_data)
				local file_index = zip.get_number_of_entries(archive) - 1
				for i = 0, file_index do
					local file = zip.extract_by_index(archive, i)
					if SET.import_event_changes and string.sub(file.name, -8) == "pw_event" then
						event_data = file.content
					elseif SET.import_level_changes and string.sub(file.name, -2) == "pw" then
						level_data = file.content
					elseif SET.import_model_changes and string.sub(file.name, -6) == "pw_art" then
						art_data = file.content
					elseif SET.import_model_changes and string.sub(file.name, -9) == "geomancer" then
						geomancer_data = file.content
					elseif SET.import_beat_changes and string.sub(file.name, -7) == "pw_beat" then
						beat_data = file.content
					end
				end
			end
		end
	else
		_, path = diags.open_folder(SET.default_path_import_model_data)
		if path then
			for filename in lfs.dir(path) do
				if not (filename == "." or filename == "..") then
					local extension = string.find(filename, "%.")
					if extension then
						extension = string.sub(filename, extension + 1)
						local function read_file(full_path)
							local f = io.open(full_path, "rb")
							if f then
								local data = f:read("*a")
								io.close(f)
								return data
							end
						end
						if SET.import_event_changes and extension == "pw_event" then
							event_data = read_file(path.."/"..filename)
						elseif SET.import_level_changes and extension == "pw" then
							level_data = read_file(path.."/"..filename)
						elseif SET.import_model_changes and extension == "pw_art" then
							art_data = read_file(path.."/"..filename)
						elseif SET.import_model_changes and extension == "geomancer" then
							geomancer_data = read_file(path.."/"..filename)
						elseif SET.import_beat_changes and extension == "pw_beat" then
							beat_data = read_file(path.."/"..filename)
						end
					end
				end
			end
		end
	end
	if UI.tab.tab_level.state and level_data then
		local level_tab = MEM.parse_json(level_data)
		if MEM.check(level_tab, "pw", "level.pw") then
			MEM.level_data.enemySet = level_tab.enemySet
			MEM.level_data.obstacleSet = level_tab.obstacleSet
			MEM.level_data.materialPropertiesSet = level_tab.materialPropertiesSet
			MEM.level_data.previewTime = level_tab.previewTime
			MEM.level_data.moveMode = level_tab.moveMode
			G.update_navbar("Level info updated")
		end
	end
	if UI.tab.tab_event.state and event_data then
		local samplesPerBeat = MEM.event_data.table.tempoSections[1].samplesPerBeat
		local beatsPerMeasure = MEM.event_data.table.tempoSections[1].beatsPerMeasure
		local startSample = MEM.event_data.table.tempoSections[1].startSample

		local event_tab = MEM.parse_json(event_data)
		if MEM.check(event_tab, "pw_event", "Selected pw_event file") then
			MEM.event_data.table = event_tab
			MEM.event_data.table.tempoSections[1].samplesPerBeat = samplesPerBeat
			MEM.event_data.table.tempoSections[1].beatsPerMeasure = beatsPerMeasure
			MEM.event_data.table.tempoSections[1].startSample = startSample
			G.update_navbar("Event data updated")
		end
	end
	if UI.tab.tab_art.state and art_data then
		local art_tab = MEM.parse_json(art_data)
		if MEM.check(art_tab, "pw_art", "Selected pw_art file") then
			local dynamic_models = {}
			if art_tab.dynamicProps then
				for key, val in ipairs(art_tab.dynamicProps) do
					dynamic_models[val.name] = true
				end
			end
			if art_tab.dynamicCullingRanges then
				for key, val in ipairs(art_tab.dynamicCullingRanges) do
					for k, v in ipairs(val.members) do
						dynamic_models[v.name] = true
					end
				end
			end
			local model_list = {}
			for key, val in ipairs(art_tab.propsDictionary) do
				model_list[val.key] = val
			end
			for key, val in ipairs(MEM.art_data.table.propsDictionary) do
				if model_list[val.key] then
					if dynamic_models[val.key] then
						val.dynamic = true
					end
					MEM.add_metadata(model_list[val.key])
					model_list[val.key].model_data.model_count = MEM.art_data.table.propsDictionary[key].model_data.model_count
					local materials_updated = false
					if not val.tween or val.tween < 1 then
						if model_list[val.key].tween > 0 then
							MEM.art_data.table.propsDictionary[key] = model_list[val.key]
							materials_updated = true
							MEM.art_data.table.propsDictionary[key].dynamic = true
						end
					end
					if not materials_updated then
						for k, v in ipairs(val.model_data.parts) do
							local new_part_tab = model_list[val.key].model_data.parts[k]
							if new_part_tab and new_part_tab.name == v.name then
								for _key in pairs(v.tab) do
									if new_part_tab.tab[_key] then
										v.tab[_key] = new_part_tab.tab[_key]
									else
										G.update_navbar("Model "..v.name.." has a wrong number of submeshes. Check if its materials ended up OK")
									end
								end
							end
						end
					end
				end
			end
		end
		if geomancer_data then
			MEM.load_geomancer_data(geomancer_data, "The geomancer metadata file")
		end
		check_geomancer_meta()
		G.update_navbar("Model data updated")
	end
	if UI.tab.tab_beat.state and beat_data then
		local beat_tab = MEM.parse_json(beat_data)
		if MEM.check(beat_tab, "pw_beat", "Selected pw_beat file") then
			local advanced_types = {Wall = true, TunnelTall = true, TunnelShort = true}
			local advanced_enemies = {FlyingBomb = true, ["Trap Enemy"] = true}
			local obstacle_count, enemy_count = 0, 0
			for key, val in ipairs(beat_tab.beatData) do
				local num_time = tonumber(val.time)
				for k, v in ipairs(val.obstacles) do
					if advanced_types[v.type] then
						for _key, list_val in ipairs(MEM.beat_data.obstacle_list) do
							local obst = MEM.beat_data.table.beatData[list_val.beat_data_key]
							local time = obst.time
							obst = obst.obstacles[list_val.obstacles_key]
							if tonumber(time) > num_time then break end
							if time == val.time and obst.placement == v.placement then
								obst.type = v.type
								obstacle_count = obstacle_count + 1
								break
							end
						end
					end
				end
				for k, v in ipairs(val.targets) do
					local change_type = advanced_enemies[v.enemyType]
					local change_sequence = advanced_sequences[v.enemySequence]
					if change_type or change_sequence then
						for _key, list_val in ipairs(MEM.beat_data.enemy_list) do
							local enemy = MEM.beat_data.table.beatData[list_val.beat_data_key]
							local time = enemy.time
							enemy = enemy.targets[list_val.enemies_key]
							if tonumber(time) > num_time then break end
							if time == val.time and enemy.placement == v.placement and enemy.distance == v.distance and
							enemy.enemyOffset == v.enemyOffset then
								if change_sequence then
									enemy.enemySequence = v.enemySequence
								end
								if change_type then
									enemy.enemyType = v.enemyType
								end
								enemy_count = enemy_count + 1
								break
							end
						end
					end
				end
			end
			local str
			if obstacle_count + enemy_count < 1 then
				str = "No changes to obstacles and enemies"
			else
				str = "Updated "
				if enemy_count > 1 then
					str = str..enemy_count.." enemies."
				elseif enemy_count > 0 then
					str = str.."one enemy"
				end
				if obstacle_count > 0 then
					if enemy_count > 0 then
						str = str.." and "
					end
					if obstacle_count > 1 then
						str = str..obstacle_count.." obstacles"
					else
						str = str.."one obstacle"
					end
				end
			end
			G.update_navbar(str)
		end
	end
end

local function evaluate_button(button)
	if button == "exit" then
		os.exit(1)
	elseif button == "klear_button" then
		local frame_length = 3 / 29.97
		local scripts = {
			{42, 442},
			{444, 818},
			{819, 1260},
			{1263, 1683},
			{1686, 1745},
			{1746, 2344},
			{2346, 2742},
			{1, 3},
			{2779, 3316},
			{3348, 3611},
			{3612, 3638},
			{3639, 3662},
			{3663, 3779},
			{3780, 4256},
			{4257, 4635},
			{4638, 5404},
			{5406, 6131},
			{6132, 6194},
			{6195, 6449},
			{6450, 6507}
		}

		for k, v in ipairs(scripts) do
			local t = {}
			for i = v[1], v[2], 3 do
				local part_name = "I2M_bad_apple_"
				if i > 99 then
					part_name = part_name..i
				else
					part_name = part_name.."0"..i
				end
				table.insert(t, {start_state = {x = 0, y = 0, z = 0}, end_state = {x = 0, y = 5, z = 0}, time = 0, type = "T", part = part_name})
				table.insert(t, {time = frame_length, type = "W"})
				table.insert(t, {start_state = {x = 0, y = 5, z = 0}, end_state = {x = 0, y = 0, z = 0}, time = 0, type = "T", part = part_name})
			end
			local ext = ".pw_tween"
			local path = "B:\\PISTOL WHIP MAPS\\tweens\\"
			path = path.."tween_"..k..ext
			local works, f = pcall(io.output, path)
			if works then
				io.write(json.encode(t))
				io.close(f)
				G.update_navbar("Done")
			else
				G.update_navbar("Error saving tween data.", true)
			end
		end
		

	elseif button == "help" then
		sys.open_url("https://mod.io/g/pistol-whip/r/geomancer")
	elseif button == "import_checkbox" then
		SET.import_changes_from_zip = not SET.import_changes_from_zip
		set_checkbox("import_checkbox", SET.import_changes_from_zip)
	elseif button == "export_folder_checkbox" then
		SET.create_folder_on_export = not SET.create_folder_on_export
		set_checkbox("export_folder_checkbox", SET.create_folder_on_export)
	elseif button == "import_level" then
		SET.import_level_changes = not SET.import_level_changes
		set_checkbox("import_level", SET.import_level_changes)
	elseif button == "import_events" then
		SET.import_event_changes = not SET.import_event_changes
		set_checkbox("import_events", SET.import_event_changes)
	elseif button == "import_models" then
		SET.import_model_changes = not SET.import_model_changes
		set_checkbox("import_models", SET.import_model_changes)
	elseif button == "import_beat" then
		SET.import_beat_changes = not SET.import_beat_changes
		set_checkbox("import_beat", SET.import_beat_changes)
	elseif button == "import_changes" then
		import_changes()
	elseif button == "degeomance" then
		if SET.confirm_degeomance then
			DIALOG.open(TAB_NAME, "dialog_confirm", {title = "Are you sure you want to remove all Geomancer changes from the loaded map?", button_1 = "Degeomance", button_3 = "Cancel", subject = "degeomance_confirm"})
		else
			degeomance()
		end
	elseif button == "load_file" then
		local num, path = diags.open("pw_meta,pw,pw_beat,pw_event,pw_geo,pw_art,pw_seq", SET.default_path_load_file)
		if path then
			local htap = string.reverse(path)
			local filename = string.reverse(string.sub(htap, 1, string.find(htap, "\\") - 1))
			local extension = string.find(htap, "%.")
			extension = string.reverse(string.sub(htap, 1, extension - 1))
			G.update_navbar("Loading "..filename, true)
			timer.delay(0.02, false, function()
				local panel = MEM.load_file(path, filename, extension)
				if panel then
					G.update_navbar("File loaded successfully")
					msg.post("/navbar#navbar", hash("update_tabs"))
					check_for_reset()
					if extension == "pw_event" then
						msg.post("/event#tab_event", hash("detect_sample_rate"))
					end
				else
					G.update_navbar("File not loaded")
				end
			end)
		end
	elseif button == "load_zip" then
		local num, path = diags.open("zip", SET.default_path_load_zip)
		if path then
			local f = io.open(path, "rb")
			if f then
				G.update_navbar("Loading files from "..path, true)
				local zip_data = f:read("*a")
				local archive = zip.open(zip_data)
				if not archive then
					G.update_navbar("Error extracting files. Try resaving the map with the current Pistol Mix version or extract the files manually.")
					return
				end
				local file_index = zip.get_number_of_entries(archive) - 1
				local skip_count, extracted_count = 0, 0
				local ext_list = {pw_meta = true, pw = true, pw_beat = true, pw_event = true, pw_geo = true, pw_art = true, pw_seq = true, geomancer = true}
				local function extract_next()
					local err, file = pcall(zip.extract_by_index, archive, file_index)
					if not err then
						G.update_navbar("Error extracting files. Try resaving the map with the current Pistol Mix version or extract the files manually.")
						return
					end
					
					local emanelif = string.reverse(file.name)
					local extension_index = string.find(emanelif, "%.")
					if extension_index then
						local extension = string.reverse(string.sub(emanelif, 1, extension_index - 1))
						if ext_list[extension] then
							local panel = MEM.load_file(nil, file.name, extension, file.content) 
							if panel then
								ext_list[extension] = false
								G.update_navbar(file.name)
								extracted_count = extracted_count + 1
							else
								skip_count = skip_count + 1
							end
						else
							skip_count = skip_count + 1
						end
					end
					file_index = file_index - 1
					if file_index < 0 then
						zip.close(archive)
						check_geomancer_meta()
						G.update_navbar("Extracted "..extracted_count.." files, "..skip_count.." skipped.")
						if MEM.level_data.sceneDisplayName then
							G.update_navbar("Loaded scene: "..MEM.level_data.sceneDisplayName)
							if MEM.level_data.mapper == "Klear" or MEM.level_data.mapper == "Klear_" or MEM.level_data.mapper == "kingklear" then
								G.update_navbar("Hey, that's one of mine! Hope you like it")
							end
						else
							G.update_navbar("Unknown scene name")
						end
						if UI.tab.tab_event.state then
							msg.post("/event#tab_event", hash("detect_sample_rate"))
						end
						msg.post("/navbar#navbar", hash("update_tabs"))
					else
						timer.delay(0.01, false, extract_next)
					end
				end
				if file_index > -1 then
					timer.delay(0.01, false, extract_next)
				else
					G.update_navbar("Archive is empty.")
				end
				check_for_reset()
			end
		end
	elseif button == "load_dir" then
		local num, path = diags.open_folder(SET.default_path_load_directory)
		if path then
			G.update_navbar("Loading files from "..path, true)
			local files_to_load = {}
			local skip_count = 0
			local ext_list = {pw_meta = true, pw = true, pw_beat = true, pw_event = true, pw_geo = true, pw_art = true, pw_seq = false, geomancer = true}
			for filename in lfs.dir(path) do
				if not (filename == "." or filename == "..") then
					local extension = string.find(filename, "%.")
					if extension then
						extension = string.sub(filename, extension + 1)
						if ext_list[extension] then
							table.insert(files_to_load, {path = path.."/"..filename, filename = filename, extension = extension})
							ext_list[extension] = false
						else
							skip_count = skip_count + 1
						end
					end
				end
			end
			if #files_to_load > 0 then
				local function load_next_file()
					local _file = table.remove(files_to_load)
					local panel = MEM.load_file(_file.path, _file.filename, _file.extension)
					if panel then
						G.update_navbar(_file.filename)
						msg.post("/navbar#navbar", hash("update_tabs"))
					else
						G.update_navbar("Error loading ".._file.filename)
					end
					if #files_to_load > 0 then
						timer.delay(0.01, false, load_next_file)
					else
						if UI.tab.tab_event.state then
							msg.post("/event#tab_event", hash("detect_sample_rate"))
						end
						check_geomancer_meta()
						if MEM.level_data.sceneDisplayName then
							G.update_navbar("Done. Loaded scene: "..MEM.level_data.sceneDisplayName)
							if MEM.level_data.mapper == "Klear" or MEM.level_data.mapper == "Klear_" or MEM.level_data.mapper == "kingklear" then
								G.update_navbar("Hey, that's one of mine! Hope you like it")
							end
						else
							G.update_navbar("Done. Unknown scene name")
						end
					end
				end
				G.update_navbar("Loading "..#files_to_load.." files, "..skip_count.." skipped.")
				timer.delay(0.01, false, load_next_file)
				check_for_reset()
			else
				G.update_navbar("No valid files found.")
			end
		end
	elseif button == "unload_all" then
		for key, val in pairs(UI.tab) do
			if not (val.state == nil) then
				val.state = false
			end
		end
		UI.tab.tab_file.state = true
		MEM.level_data = {}
		MEM.meta_data = {}
		MEM.beat_data = {}
		MEM.event_data = {}
		MEM.geo_data = {}
		MEM.sequence_data = {}
		MEM.art_data = {}

		msg.post("/event#tab_event", hash("reset"))
		G.update_navbar("All data unloaded.", true)
		msg.post("/navbar#navbar", hash("update_tabs"))
	elseif button == "export_all" then
		export_all(not SET.create_folder_on_export)
	end
end

function on_input(self, action_id, action)
	UI.on_input(TAB_NAME, action_id, action, evaluate_button)
end