local UI = require "modules.ui"
local MEM = require "modules.memory"
local G = require "modules.global"
local SET = require "modules.settings"
local DIALOG = UI.DIALOG
local TAB_NAME = "tab_file"

local files_to_export

local function set_checkbox(checkbox, value)
	if value then
		gui.set_text(gui.get_node(checkbox.."/text"), "X")
	else
		gui.set_text(gui.get_node(checkbox.."/text"), "")
	end
end

function init(self)
	gui.set_render_order(1)
	gui.set_text(gui.get_node("version_label"), "Version "..sys.get_config("project.version"))
	UI.load_template({"exit", "load_dir", "load_file", "load_zip", "unload_all", "export_all", "export_folder_checkbox", "import_changes",
	"import_checkbox", "degeomance", "import_level", "import_events", "import_beat", "import_models", "help"}, TAB_NAME)
	set_checkbox("import_checkbox", SET.import_changes_from_zip)
	set_checkbox("export_folder_checkbox", SET.create_folder_on_export)
	set_checkbox("import_level", SET.import_level_changes)
	set_checkbox("import_events", SET.import_event_changes)
	set_checkbox("import_beat", SET.import_beat_changes)
	set_checkbox("import_models", SET.import_model_changes)
end

local function run_export_fn()
	for key, val in ipairs(files_to_export) do
		val.fn(val.path)
		msg.post("/navbar#navbar", hash("update_status"), {text = val.text})
	end
	msg.post("/navbar#navbar", hash("update_status"), {text = "Files exported"})
	files_to_export = nil
end

function on_message(self, message_id, message, sender)
	if message_id == hash("hide") then
		msg.post("#", hash("disable"))
		msg.post("#", hash("release_input_focus"))
		DIALOG.close_all(TAB_NAME)
	elseif message_id == hash("show") then
		msg.post("#", hash("enable"))
		msg.post("#", hash("acquire_input_focus"))
	elseif message_id == hash("dialog_closed") then
		msg.post("#", hash("acquire_input_focus"))
		if message.dialog == "dialog_confirm" then
			if message.subject == "overwrite_export" then
				if message.button == 1 then 			-- buttons are 1 = overwrite, 3 = cancel
					run_export_fn()
				else
					files_to_export = nil
					msg.post("/navbar#navbar", hash("update_status"), {text = "Export aborted", clear = true})
				end
			end
		end
	end
end

local function update_panel(extension)
	if extension == "pw_event" then
		msg.post("/event#tab_event", hash("update"))
	end
end

local function check_for_reset()
	if MEM.event_reloaded then
		msg.post("/event#tab_event", hash("reset"))
		MEM.event_reloaded = nil
	end
	if MEM.art_reloaded then
		msg.post("/art#tab_art", hash("reset"))
		MEM.art_reloaded = nil
	end
	if MEM.beat_reloaded then
		msg.post("/beat#tab_beat", hash("reset"))
		MEM.beat_reloaded = nil
	end
	if MEM.slices_reloaded then
		msg.post("/meta#tab_meta", hash("reset"))
		MEM.slices_reloaded = nil
	end
end

local function export_level(path)
	local full_string = MEM.level_data.string
	local _, start_index = string.find(full_string, "\"previewTime\"")
	local end_index = string.find(full_string, ",", start_index + 1)
	local final_string = string.sub(full_string, 1, start_index + 1)..tostring(MEM.level_data.preview_time)..string.sub(full_string, end_index)
	local function replace_string(pattern, new_value)
		_, start_index = string.find(final_string, pattern)
		end_index = string.find(final_string, ",", start_index + 2)
		final_string = string.sub(final_string, 1, start_index + 2)..new_value..string.sub(final_string, end_index - 1)
	end
	replace_string("\"obstacleSet\"", MEM.level_data.obstacle_set)
	replace_string("\"materialPropertiesSet\"", MEM.level_data.material_set)
	replace_string("\"enemySet\"", MEM.level_data.enemy_set)
	replace_string("\"moveMode\"", MEM.level_data.move_mode)

	if not G.safe_decode(final_string, "level.pw") then
		msg.post("/navbar#navbar", hash("update_status"), {text = "Level data might be corrupted. Use with caution."})
	end

	local f = G.safe_output(path)
	if f then
		io.write(final_string)
		io.close(f)
	end
end

local function export_event(path)
	local nobeat_str = "{\"version\":\"0.4\",\"eventsData\":[{\"track\":\"NoBeat\",\"events\":["
	local nobeat_tab = MEM.event_data.table.eventsData[MEM.event_data.nobeat_track_index].events
	for key, val in ipairs(nobeat_tab) do
		nobeat_str = nobeat_str.."{\"startSample\":\""..val.startSample.."\",\"endSample\":\""..val.endSample.."\",\"payload\":\"\"}"
		if not (key == #nobeat_tab) then
			nobeat_str = nobeat_str..","
		end
	end
	local signal_str = "]},{\"track\":\"Event\",\"events\":["
	local signal_tab = MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events
	for key, val in ipairs(signal_tab) do
		if not val.endSample then
			val.endSample = val.startSample
		end
		signal_str = signal_str.."{\"startSample\":\""..val.startSample.."\",\"endSample\":\""..val.endSample.."\",\"payload\":\""..val.payload.."\"}"
		if not (key == #signal_tab) then
			signal_str = signal_str..","
		end
	end
	local tempo_str = "]},{\"track\":\"GameplayProp\",\"events\":[]}],\"tempoSections\":["
	local tempo_tab = MEM.event_data.table.tempoSections
	for key, val in ipairs(tempo_tab) do
		tempo_str = tempo_str.."{\"startSample\":"..val.startSample..",\"samplesPerBeat\":"..val.samplesPerBeat..",\"beatsPerMeasure\":"..val.beatsPerMeasure.."}"
		if not (key == #tempo_tab) then
			tempo_str = tempo_str..","
		end
	end
	local final_string = nobeat_str..signal_str..tempo_str.."]}"
	if not G.safe_decode(final_string, "Output pw_event file") then
		msg.post("/navbar#navbar", hash("update_status"), {text = "Event data might be corrupted. Use with caution."})
	end
	local f = G.safe_output(path)
	if f then
		io.write(final_string)
		io.close(f)
	end
end

local function export_art(path)
	local static_ranges_changed, dynamic_ranges_changed
	local existing_ranges, existing_dynamic_ranges = {}, {}
	for key, val in ipairs(MEM.art_data.table_culling_ranges) do
		existing_ranges[val.range] = val
	end
	for key, val in ipairs(MEM.art_data.table_dynamic_culling_ranges) do
		existing_dynamic_ranges[val.range] = val
	end
	local tab_iter = MEM.art_data.table_static_props
	for i = #tab_iter, 1, -1 do
		if MEM.art_data.dynamic_models[tab_iter[i].name] then
			local r = table.remove(tab_iter, i)
			table.insert(MEM.art_data.table_dynamic_props, r)
		end
	end
	tab_iter = MEM.art_data.table_dynamic_props
	for i = #tab_iter, 1, -1 do
		if not MEM.art_data.dynamic_models[tab_iter[i].name] then
			local r = table.remove(tab_iter, i)
			table.insert(MEM.art_data.table_static_props, r)
		end
	end
	tab_iter = MEM.art_data.table_culling_ranges
	local range
	local test = false
	for i = #tab_iter, 1, -1 do
		range = tab_iter[i].range
		test = (range == "24,25")
		local member_count = #tab_iter[i].members
		for j = #tab_iter[i].members, 1, -1 do
			if MEM.art_data.dynamic_models[tab_iter[i].members[j].name] then
				local r = table.remove(tab_iter[i].members, j)
				if existing_dynamic_ranges[range] then
					table.insert(existing_dynamic_ranges[range].members, r)
				else
					MEM.art_data.table_dynamic_culling_ranges[#MEM.art_data.table_dynamic_culling_ranges + 1] = {range = range, members = {r}}
					existing_dynamic_ranges[range] = MEM.art_data.table_dynamic_culling_ranges[#MEM.art_data.table_dynamic_culling_ranges]
					dynamic_ranges_changed = true
				end
				member_count = member_count - 1
			end
		end
		if member_count < 1 then
			table.remove(tab_iter, i)
		end
	end
	tab_iter = MEM.art_data.table_dynamic_culling_ranges
	local range
	for i = #tab_iter, 1, -1 do
		range = tab_iter[i].range
		local member_count = #tab_iter[i].members
		for j = #tab_iter[i].members, 1, -1 do
			if not MEM.art_data.dynamic_models[tab_iter[i].members[j].name] then
				local r = table.remove(tab_iter[i].members, j)
				if existing_ranges[range] then
					table.insert(existing_ranges[range].members, r)
				else
					MEM.art_data.table_culling_ranges[#MEM.art_data.table_culling_ranges + 1] = {range = range, members = {r}}
					existing_ranges[range] = MEM.art_data.table_culling_ranges[#MEM.art_data.table_culling_ranges]
					static_ranges_changed = true
				end
				member_count = member_count - 1
			end
		end
		if member_count < 1 then
			table.remove(tab_iter, i)
		end
	end

	local function range_to_number(range_str)
		local comma = string.find(range_str, ",")
		local first = tonumber(string.sub(range_str, 1, comma - 1))
		local second = tonumber(string.sub(range_str, comma +1))
		return first + (second * 0.001)
	end

	if static_ranges_changed then
		table.sort(MEM.art_data.table_culling_ranges, function(a, b) return range_to_number(a.range) < range_to_number(b.range) end)
	end
	if dynamic_ranges_changed then
		table.sort(MEM.art_data.table_dynamic_culling_ranges, function(a, b) return range_to_number(a.range) < range_to_number(b.range) end)
	end

	local final_string = MEM.art_data.string_colours.."\"staticProps\":["
	local str = ""
	for key, val in ipairs(MEM.art_data.table_static_props) do
		str = str.."{\"name\":\""..val.name.."\",\"point\":\""..val.point.."\",\"scale\":\""..val.scale.."\"}"
		if not (key == #MEM.art_data.table_static_props) then
			str = str..","
		end
	end
	final_string = final_string..str.."],\"staticCullingRanges\":["
	str = ""
	for key, val in ipairs(MEM.art_data.table_culling_ranges) do
		str = str.."{\"range\":\""..val.range.."\",\"members\":["
		for k, v in ipairs(val.members) do
			str = str.."{\"name\":\""..v.name.."\",\"point\":\""..v.point.."\",\"scale\":\""..v.scale.."\"}"
			if not (k == #val.members) then
				str = str..","
			else
				str = str.."]}"
			end
		end
		if not (key == #MEM.art_data.table_culling_ranges) then
			str = str..","
		end
	end
	final_string = final_string..str.."],"

	if next(MEM.art_data.dynamic_models) then
		str = "\"dynamicProps\":["
		for key, val in ipairs(MEM.art_data.table_dynamic_props) do
			str = str.."{\"name\":\""..val.name.."\",\"point\":\""..val.point.."\",\"scale\":\""..val.scale.."\"}"
			if not (key == #MEM.art_data.table_dynamic_props) then
				str = str..","
			end
		end
		final_string = final_string..str.."],\"dynamicCullingRanges\":["
		str = ""
		for key, val in ipairs(MEM.art_data.table_dynamic_culling_ranges) do
			str = str.."{\"range\":\""..val.range.."\",\"members\":["
			for k, v in ipairs(val.members) do
				str = str.."{\"name\":\""..v.name.."\",\"point\":\""..v.point.."\",\"scale\":\""..v.scale.."\"}"
				if not (k == #val.members) then
					str = str..","
				else
					str = str.."]}"
				end
			end
			if not (key == #MEM.art_data.table_dynamic_culling_ranges) then
				str = str..","
			end
		end
		final_string = final_string..str.."],"
	end
	local function get_tween_string(tween_data, model_name)
		if not tween_data then
			return ""
		else
			local str = ",{\"type\":\"ScriptedTween\",\"Script\":\""
			local deletion_count = 0
			
			tween_data.script, deletion_count = G.expand_repeat_actions(tween_data.script)

			if deletion_count == 1 then
				msg.post("/navbar#navbar", hash("update_status"), {text = "An invalid repeat action has been removed from tween of "..model_name})
			elseif deletion_count > 1 then
				msg.post("/navbar#navbar", hash("update_status"), {text = deletion_count.." invalid repeat actions have been removed from tween of "..model_name})
			end

			for key, val in ipairs(tween_data.script) do
				if val.type == "W" then
					str = str..val.type..val.time..";"
				else
					if val.easing then
						local x_diff = val.end_state.x - val.start_state.x
						local y_diff = val.end_state.y - val.start_state.y
						local z_diff = val.end_state.z - val.start_state.z
						if val.type == "R" then
							if x_diff > 180 then
								x_diff = x_diff - 360
							elseif x_diff < -180 then
								x_diff = x_diff + 360
							end
							if y_diff > 180 then
								y_diff = y_diff - 360
							elseif y_diff < -180 then
								y_diff = y_diff + 360
							end
							if z_diff > 180 then
								z_diff = z_diff - 360
							elseif z_diff < -180 then
								z_diff = z_diff + 360
							end
						end
						local node_tab = val.easing.nodes
						for i = 1, #node_tab - 1 do
							local s_x = val.start_state.x + (node_tab[i].comp * x_diff)
							local s_y = val.start_state.y + (node_tab[i].comp * y_diff)
							local s_z = val.start_state.z + (node_tab[i].comp * z_diff)
							local e_x = val.start_state.x + (node_tab[i + 1].comp * x_diff)
							local e_y = val.start_state.y + (node_tab[i + 1].comp * y_diff)
							local e_z = val.start_state.z + (node_tab[i + 1].comp * z_diff)
							local t = val.time * (node_tab[i + 1].time - node_tab[i].time)
							str = str..val.type..MEM.art_data.part_names[model_name][val.part]..";"
							str = str..s_x..","..s_y..","..s_z..";"
							str = str..e_x..","..e_y..","..e_z..";"..t..";"
						end
					else
						str = str..val.type..MEM.art_data.part_names[model_name][val.part]..";"..val.start_state.x..","..val.start_state.y..","
						str = str..val.start_state.z..";"..val.end_state.x..","..val.end_state.y..","..val.end_state.z..";"..val.time..";"
					end
				end
			end
			return str.."\"},{\"type\":\"LevelEventReceiver\",\"EventId\":\""..tween_data.signal.."\",\"ActionType\":\"ScriptedTweenTrigger\"}"
		end
	end
	str = ""
	for key, val in ipairs(MEM.art_data.model_list) do
		local cursor_start = string.find(val.string, "\"components\"") + 14
		local cursor_end = string.find(val.string, "]", cursor_start) - 1
		local component_string = string.sub(val.string, cursor_start, cursor_end)
		local script_pos = string.find(component_string, "{\"type\":\"ScriptedTween\"")
		if script_pos then
			local script_end = string.find(component_string, "}", script_pos)
			component_string = string.sub(component_string, 1, script_pos - 1)..string.sub(component_string, script_end + 1)
		end
		local trigger_pos = string.find(component_string, "{\"type\":\"LevelEventReceiver\"")
		if trigger_pos then
			local trigger_end = string.find(component_string, "}", trigger_pos)
			component_string = string.sub(component_string, 1, trigger_pos - 1)..string.sub(component_string, trigger_end + 1)
		end
		if val.tween then
			for k, v in ipairs(val.tween.script) do
				if v.part == 0 then
					local root = MEM.get_root_transform(val.string)
					MEM.art_data.part_names[val.name][0] = root or "Mesh"
					if not root then
						local children_end = string.find(val.string, "\"children\":") + 12
						local mesh_string = "\"name\":\"Mesh\",\"components\":[{\"type\":\"Transform\",\"values\":\"0,0,0,0,0,0,1,1,1,1\"}],\"children\":[{"
						val.string = string.sub(val.string, 1, children_end)..mesh_string..string.sub(val.string, children_end + 1, -2).."]}}"
					end
				end
			end
		end
		component_string = G.sanitise_json(component_string..get_tween_string(val.tween, val.name))
		val.string = string.sub(val.string, 1, cursor_start - 1)..component_string..string.sub(val.string, cursor_end + 1)
		if key < #MEM.art_data.model_list then
			str = str..val.string..","
		else
			str = str..val.string.."]"
		end
	end
	final_string = final_string..MEM.art_data.string_dictionary..str.."}"
	if not G.safe_decode(final_string, "Output pw_art file") then
		msg.post("/navbar#navbar", hash("update_status"), {text = "Model data might be corrupted. Use with caution."})
	end
	local f = G.safe_output(path)
	if f then
		io.write(final_string)
		io.close(f)
	end
end

local function export_beat(path)
	for beat_data_key, val in pairs(MEM.beat_data.changed_obstacles) do
		local t = MEM.beat_data.table[beat_data_key].time
		local find_time = string.find(MEM.beat_data.string, "\"time\":\""..t)
		local obstacles_start = string.find(MEM.beat_data.string, "\"obstacles\"", find_time) + 11
		local obstacles_end = string.find(MEM.beat_data.string, "]", obstacles_start, true) + 1
		local js = json.encode(MEM.beat_data.table[beat_data_key].obstacles)
		MEM.beat_data.string = string.sub(MEM.beat_data.string, 1, obstacles_start)..js..string.sub(MEM.beat_data.string, obstacles_end)
	end
	local used_keys = {}
	for key in pairs(MEM.beat_data.changed_enemies) do
		local beat_data_key = MEM.beat_data.enemy_list[key].beat_data_key
		if not used_keys[beat_data_key] then
			used_keys[beat_data_key] = true
			local t = MEM.beat_data.table[beat_data_key].time
			local find_time = string.find(MEM.beat_data.string, "\"time\":\""..t)
			local targets_start = string.find(MEM.beat_data.string, "\"targets\"", find_time) + 9
			local targets_end = string.find(MEM.beat_data.string, "]", targets_start, true) + 1

			local targets_tab = {}
			
			local start_index = key - MEM.beat_data.enemy_list[key].enemies_key + 1
			repeat
				local e = MEM.beat_data.enemy_list[start_index]
				if e.beat_data_key == beat_data_key then
					table.insert(targets_tab, {
						enemyType = e.type, distance = e.distance, placement = e.placement, enemyOffset = e.offset, enemySequence = e.sequence,
						bonusEnemy = e.bonus, shielded = e.shielded, noGround = e.no_ground, noCarve = e.no_carve
					})
					start_index = start_index + 1
				else
					break
				end
			until start_index > #MEM.beat_data.enemy_list
			local js = json.encode(targets_tab)
			MEM.beat_data.string = string.sub(MEM.beat_data.string, 1, targets_start)..js..string.sub(MEM.beat_data.string, targets_end)
		end
	end
	if not G.safe_decode(MEM.beat_data.string, "Output beat data file") then
		msg.post("/navbar#navbar", hash("update_status"), {text = "Beat data might be corrupted. Use with caution."})
	end
	local f = G.safe_output(path)
	if f then
		io.write(MEM.beat_data.string)
		io.close(f)
	end
end

local function export_geo(path)
	local final_string = MEM.geo_data.start..MEM.geo_data.chunk..MEM.geo_data.slices
	if not G.safe_decode(final_string, "Output pw_geo file") then
		msg.post("/navbar#navbar", hash("update_status"), {text = "Geo data might be corrupted. Use with caution."})
	end
	local f = G.safe_output(path)
	if f then
		io.write(final_string)
		io.close(f)
	end
end

local function export_slice(path)
	local output_string = ""
	if #MEM.meta_data.volumes < 1 then
		output_string = MEM.meta_data.string_start..MEM.meta_data.string_end
	else
		if #MEM.meta_data.volume_table > 0 then
			output_string = ","
		end
		for key, val in ipairs(MEM.meta_data.volumes) do
			output_string = output_string..val
			if key < #MEM.meta_data.volumes then
				output_string = output_string..","
			end
		end
		output_string = MEM.meta_data.string_start..output_string..MEM.meta_data.string_end
	end

	if not G.safe_decode(output_string, "do_not_ship.pw_meta") then
		msg.post("/navbar#navbar", hash("update_status"), {text = "Meta data might be corrupted. Use with caution."})
	end

	local f = G.safe_output(path)
	if f then
		io.write(output_string)
		io.close(f)
	end
end

local function export_all(overwrite)
	if UI.tab.tab_level.state or UI.tab.tab_event.state or UI.tab.tab_geo.state or UI.tab.tab_beat.state or UI.tab.tab_meta.state or UI.tab.tab_art.state then
		local num, path
		if overwrite then
			num, path = diags.open_folder(SET.default_path_export)
		else
			num, path = diags.open_folder(SET.default_path_export_overwrite)
		end
		if path then
			local filenames = {}
			local common_filename = "map"
			local function get_name(s)
				if s then
					local ext = string.find(s, "%.")
					return string.sub(s, 1, ext - 1)
				end
			end
			local function get_art_name(s)
				if s then
					local shared = string.find(MEM.art_data.filename, "_SharedArt") or -7 -- In case _SharedArt not found in filename just remove the extension
					return string.sub(MEM.art_data.filename, 1, shared - 1)
				end
			end
			filenames.beat = get_name(MEM.beat_data.filename)
			filenames.event = get_name(MEM.event_data.filename)
			filenames.geo = get_name(MEM.geo_data.filename)
			filenames.art = get_art_name(MEM.art_data.filename)
			if next(filenames) then
				common_filename = filenames[next(filenames)]
				for key, val in pairs(filenames) do
					if not (val == common_filename) then
						common_filename = get_art_name(MEM.level_data.art_file) or filenames.art or filenames.event or filenames.beat or filenames.geo
						break
					end
				end
			end
			if not overwrite then
				path = path.."\\"..common_filename.."_geomanced"
				if not lfs.mkdir(path) then
					local index = 0
					repeat
						index = index + 1
						if index > 1000 then
							msg.post("/navbar#navbar", hash("update_status"), {text = "Cannot create folder. Export aborted"})
							return
						end
					until lfs.mkdir(path.."("..index..")")
					path = path.."("..index..")"
				end
				msg.post("/navbar#navbar", hash("update_status"), {text = "Exporting files to "..path, clear = true})
				if MEM.level_data.string then
					export_level(path.."\\level.pw")
					msg.post("/navbar#navbar", hash("update_status"), {text = "Level settings exported"})
				end
				if MEM.event_data.string then
					export_event(path.."\\"..common_filename..".pw_event")
					msg.post("/navbar#navbar", hash("update_status"), {text = "Events exported"})
				end
				if MEM.art_data.table_static_props then
					export_art(path.."\\"..common_filename.."_SharedArt.pw_art")
					msg.post("/navbar#navbar", hash("update_status"), {text = "Model data exported"})
				end
				if MEM.beat_data.string then
					export_beat(path.."\\"..common_filename..".pw_beat")
					msg.post("/navbar#navbar", hash("update_status"), {text = "Enemies exported"})
				end
				if MEM.geo_data.start then
					export_geo(path.."\\"..common_filename..".pw_geo")
					msg.post("/navbar#navbar", hash("update_status"), {text = "Geo exported"})
				end
				if MEM.meta_data.string then
					export_slice(path.."\\do_not_ship.pw_meta")
				end
				msg.post("/navbar#navbar", hash("update_status"), {text = "Files exported to "..path})
			else
				msg.post("/navbar#navbar", hash("update_status"), {text = "Starting export", clear = true})
				files_to_export = {}
				local full_path
				if MEM.level_data.string then
					full_path = path.."\\level.pw"
					table.insert(files_to_export, {fn = export_level, path = full_path, exists = sys.exists(full_path), text = "Level settings exported"})
				end
				if MEM.event_data.string then
					full_path = path.."\\"..common_filename..".pw_event"
					table.insert(files_to_export, {fn = export_event, path = full_path, exists = sys.exists(full_path), text = "Events exported"})
				end
				if MEM.art_data.table_static_props then
					full_path = path.."\\"..common_filename.."_SharedArt.pw_art"
					table.insert(files_to_export, {fn = export_art, path = full_path, exists = sys.exists(full_path), text = "Model data exported"})
				end
				if MEM.beat_data.string then
					full_path = path.."\\"..common_filename..".pw_beat"
					table.insert(files_to_export, {fn = export_beat, path = full_path, exists = sys.exists(full_path), text = "Enemies exported"})
				end
				if MEM.geo_data.start then
					full_path = path.."\\"..common_filename..".pw_geo"
					table.insert(files_to_export, {fn = export_geo, path = full_path, exists = sys.exists(full_path), text = "Geo exported"})
				end
				if MEM.meta_data.string then
					full_path = path.."\\do_not_ship.pw_meta"
					local text
					if #MEM.meta_data.volumes > 0 then
						text = "Volumes exported. NOTE: this does nothing until you open the map in Pistol Mix and generate geo."
					else
						text = "do_not_ship.pw_meta exported."
					end
					table.insert(files_to_export, {fn = export_slice, path = full_path, exists = sys.exists(full_path), text = text})
				end
				local overwrite_count = 0
				for key, val in ipairs(files_to_export) do
					if val.exists then
						overwrite_count = overwrite_count + 1
					end
				end
				if overwrite_count < 1 then
					run_export_fn()
				elseif not SET.confirm_file_overwrite then
					msg.post("/navbar#navbar", hash("update_status"), {text = "Exporting files to "..path.."\nEXISTING FILES ARE BEING OVERWRITTEN", clear = true})
					run_export_fn()
				else
					local title = overwrite_count.." files will be overwritten. Continue with export?"
					DIALOG.open(TAB_NAME, "dialog_confirm", {title = title, button_1 = "Overwrite", button_3 = "Cancel", subject = "overwrite_export"})
				end
			end
		end
	else
		msg.post("/navbar#navbar", hash("update_status"), {text = "Nothing to export", clear = true})
	end
end

local advanced_sequences = 	{
	__Flying_ATTACK = true,
	["Zig_shoot _Zag_shoot"] = true,
	Strafe_shoot_retreat = true,
	FWD_RGHT_FWD_SHT = true,
	["STRAFE SHOOT x3"] = true,
	--		High_FlyingSkull Basic = true,
	--		ONBEAT_High_FlyingSkull = true,
	--		FlyingSkull Basic = true,
	--		FlyingSkull Short
	--		DefaultEnemySequence_Jetpack = true,
	BeatSpawn_Jetpack_Stationary = true,
	["_Run Roll Shoot"] = true,
	--		__SniperJoeTest = true,
	--		ImmediateDespawn = true,
	CrookedTestSequence = true,
	["EmptyEnemySequence 1"] = true,
	Run_Slide_Shoot_01 = true,
	_VaultShoot_01 = true,
	ENME_SEQ_06 = true,
	ENME_SEQ_07 = true,
	StrafeRightLeft = true,
	Canter_Forward_Shoot = true,
	TestEnemySequence = true
}

local function degeomance()
	if not (UI.tab.tab_level.state or UI.tab.tab_event.state or UI.tab.tab_beat.state or UI.tab.tab_art.state or UI.tab.tab_meta.state) then
		G.update_navbar("You must open a map first.", true)
		return
	end
	G.update_navbar("De-geomancing map", true)
	if UI.tab.tab_level.state then
		local change = false
		if not (MEM.level_data.preview_time == 0) then
			MEM.level_data.preview_time = 0
			G.update_navbar("Preview time reset to 0")
			change = true
		end
		if not (MEM.level_data.move_mode == "Moving") then
			MEM.level_data.move_mode = "Moving"
			G.update_navbar("Move mode set to Moving")
			change = true
		end
		if not change then
			G.update_navbar("No level info changes necessary")
		end
	end
	if UI.tab.tab_event.state then
		local nobeat_count = #MEM.event_data.table.eventsData[MEM.event_data.nobeat_track_index].events
		local event_count = #MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events
		local tempo_count = #MEM.event_data.table.tempoSections
		MEM.event_data.table.eventsData[MEM.event_data.nobeat_track_index].events = {}
		local skipped_count = 0
		if not MEM.level_data.obstacle_set then
			for key = event_count, 1, -1 do
				local payload = MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events[key].payload
				if (payload == "PillarDrop") or (payload == "RisePillar") then
					event_count = event_count - 1
				else
					table.remove(MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events, key)
				end
			end
		elseif MEM.level_data.obstacle_set == "AirDrop" then
			for key = event_count, 1, -1 do
				local payload = MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events[key].payload
				if payload == "PillarDrop" then
					event_count = event_count - 1
					skipped_count = skipped_count + 1
				else
					table.remove(MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events, key)
				end
			end
			if MEM.beat_data.obstacle_list then
				if skipped_count < #MEM.beat_data.obstacle_list then
					local new_event_count = #MEM.beat_data.obstacle_list - skipped_count
					for i = 1, new_event_count do
						msg.post(UI.tab.tab_event.path, hash("add_event"), {start_sample = i, signal = "PillarDrop"})
					end
					if new_event_count > 1 then
						G.update_navbar("Created "..new_event_count.." PillarDrop events at the start of the map.")
					else
						G.update_navbar("Created a PillarDrop event at the start of the map.")
					end
				end
			end
		elseif MEM.level_data.obstacle_set == "Spooky" then
			for key = event_count, 1, -1 do
				local payload = MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events[key].payload
				if payload == "RisePillar" then
					event_count = event_count - 1
					skipped_count = skipped_count + 1
				else
					table.remove(MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events, key)
				end
			end
			if MEM.beat_data.obstacle_list then
				if skipped_count < #MEM.beat_data.obstacle_list then
					local new_event_count = #MEM.beat_data.obstacle_list - skipped_count
					for i = 1, new_event_count do
						msg.post(UI.tab.tab_event.path, hash("add_event"), {start_sample = i, signal = "RisePillar"})
					end
					if new_event_count > 1 then
						G.update_navbar("Created "..new_event_count.." RisePillar events at the start of the map.")
					else
						G.update_navbar("Created a RisePillar event at the start of the map.")
					end
				end
			end
		else
			MEM.event_data.table.eventsData[MEM.event_data.event_track_index].events = {}
		end
		
		
		if #MEM.event_data.table.tempoSections > 1 then
			MEM.event_data.table.tempoSections = {MEM.event_data.table.tempoSections[1]}
		end
		local change = false
		if nobeat_count > 1 then
			G.update_navbar("Removed "..nobeat_count.." no-beat sections")
			change = true
		elseif nobeat_count > 0 then
			G.update_navbar("Removed one no-beat section")
			change = true
		end
		if event_count > 1 then
			G.update_navbar("Removed "..event_count.." event triggers")
			change = true
		elseif event_count > 0 then
			G.update_navbar("Removed one event trigger")
			change = true
		end
		if tempo_count > 2 then
			G.update_navbar("Removed "..(tempo_count - 1).." tempo sections")
			change = true
		elseif tempo_count > 1 then
			G.update_navbar("Removed one tempo section")
			change = true
		end
		if not change then
			G.update_navbar("No event file changes necessary")
		end
	end
	if UI.tab.tab_art.state then
		msg.post("/art#tab_art", hash("degeomance"))
	end
	if UI.tab.tab_beat.state then
		local obstacle_count, enemy_type_count, sequence_count = 0, 0, 0
		local obstacle_types = {Wall = "Sidestep", TunnelTall = "LimboTall", TunnelShort = "LimboShort"}
		for key, val in ipairs(MEM.beat_data.obstacle_list) do
			if obstacle_types[val.type] then
				obstacle_count = obstacle_count + 1
				val.type = obstacle_types[val.type]
				MEM.beat_data.changed_obstacles[val.beat_data_key] = true
				MEM.beat_data.table[val.beat_data_key].obstacles[val.obstacles_key].type = val.type
			end
		end

		local enemy_names = {
			Normal = "normal",
			Tough = "tough",
			ChuckNorris = "chuck",
			["Mounted Enemy"] = "horse",
			Shield = "shield",
			["Normal Turret"] = "turret",
			["Minigun Turret"] = "minigun",
			FlyingBomb = "skull",
			["Trap Enemy"] = "trap"
		}
		
		for key, val in ipairs(MEM.beat_data.enemy_list) do
			if val.type == "FlyingBomb" then
				val.type = SET.degeomance_skull
				MEM.beat_data.enemy_types[enemy_names[SET.degeomance_skull]] = true
				MEM.beat_data.changed_enemies[key] = true
				enemy_type_count = enemy_type_count + 1
			elseif val.type == "Trap Enemy" then
				val.type = SET.degeomance_glitched_enemy
				MEM.beat_data.enemy_types[enemy_names[SET.degeomance_glitched_enemy]] = true
				MEM.beat_data.changed_enemies[key] = true
			end
			if advanced_sequences[val.sequence] then
				val.sequence = SET.degeomance_sequence
				MEM.beat_data.changed_enemies[key] = true
				sequence_count = sequence_count + 1
			end
			MEM.beat_data.enemy_types.FlyingBomb = false
			MEM.beat_data.enemy_types["Trap Enemy"] = false
		end
		local change = false
		if obstacle_count > 1 then
			G.update_navbar("Changed "..obstacle_count.." obstacles")
			change = true
		elseif obstacle_count > 0 then
			G.update_navbar("Changed one obstacle")
			change = true
		end
		if enemy_type_count > 1 then
			G.update_navbar("Changed "..enemy_type_count.." enemy types")
			change = true
		elseif enemy_type_count > 0 then
			G.update_navbar("Changed one enemy type")
			change = true
		end
		if sequence_count > 1 then
			G.update_navbar("Changed "..sequence_count.." sequences")
			change = true
		elseif sequence_count > 0 then
			G.update_navbar("Changed one sequence")
			change = true
		end
	end
	if UI.tab.tab_meta.state then
		
	end
end

local function import_changes()
	if not ((SET.import_level_changes and UI.tab.tab_level.state) or (SET.import_event_changes and UI.tab.tab_event.state) or
	(SET.import_beat_changes and UI.tab.tab_beat.state) or (SET.import_model_changes and UI.tab.tab_art.state)) then
		G.update_navbar("You must open a map first.", true)
		return
	else
		G.update_navbar("Importing changes", true)
	end
	local _, path, tab, level_data, event_data, art_data, beat_data, filename
	local error = false
	if SET.import_changes_from_zip then
		_, path = diags.open("zip", SET.default_path_import_model_data)
		if path then
			local f = io.open(path, "rb")
			if f then
				local zip_data = f:read("*a")
				local archive = zip.open(zip_data)
				local file_index = zip.get_number_of_entries(archive) - 1
				for i = 0, file_index do
					local file = zip.extract_by_index(archive, i)
					if SET.import_event_changes and string.sub(file.name, -8) == "pw_event" then
						event_data = file.content
					elseif SET.import_level_changes and string.sub(file.name, -2) == "pw" then
						level_data = file.content
					elseif SET.import_model_changes and string.sub(file.name, -6) == "pw_art" then
						art_data = file.content
					elseif SET.import_beat_changes and string.sub(file.name, -7) == "pw_beat" then
						beat_data = file.content
					end
				end
			else
				error = true
			end
		else
			error = true
		end
	else
		_, path = diags.open_folder(SET.default_path_import_model_data)
		if path then
			local files_to_load = {}
			for filename in lfs.dir(path) do
				if not (filename == "." or filename == "..") then
					local extension = string.find(filename, "%.")
					if extension then
						extension = string.sub(filename, extension + 1)
						local function read_file(full_path)
							local f = io.open(full_path, "rb")
							if f then
								local data = f:read("*a")
								io.close(f)
								return data
							else
								error = true
							end
						end
						if SET.import_event_changes and extension == "pw_event" then
							event_data = read_file(path.."/"..filename)
						elseif SET.import_level_changes and extension == "pw" then
							level_data = read_file(path.."/"..filename)
						elseif SET.import_model_changes and extension == "pw_art" then
							art_data = read_file(path.."/"..filename)
						elseif SET.import_beat_changes and extension == "pw_beat" then
							beat_data = read_file(path.."/"..filename)
						end
					end
				end
			end
		else
			error = true
		end
	end
	if UI.tab.tab_level.state and level_data then
		local level_tab = G.safe_decode(level_data, "Level data")
		if level_tab then
			MEM.level_data.enemy_set = level_tab.enemySet
			MEM.level_data.obstacle_set = level_tab.obstacleSet
			MEM.level_data.material_set = level_tab.materialPropertiesSet
			MEM.level_data.preview_time = level_tab.previewTime
			MEM.level_data.move_mode = level_tab.moveMode
			G.update_navbar("Level info updated")
		end
	end
	if UI.tab.tab_event.state and event_data then
		local samplesPerBeat = MEM.event_data.table.tempoSections[1].samplesPerBeat
		local beatsPerMeasure = MEM.event_data.table.tempoSections[1].beatsPerMeasure
		local startSample = MEM.event_data.table.tempoSections[1].startSample
		local panel = MEM.load_file(nil, nil, "pw_event", event_data)
		MEM.event_data.table.tempoSections[1].samplesPerBeat = samplesPerBeat
		MEM.event_data.table.tempoSections[1].beatsPerMeasure = beatsPerMeasure
		MEM.event_data.table.tempoSections[1].startSample = startSample
		if panel then
			G.update_navbar("Event data updated")
		else
			G.update_navbar("Error loading event data")
		end
		MEM.event_reloaded = false
	end
	if UI.tab.tab_art.state and art_data then
		MEM.art_data.temp = art_data
		msg.post("/art#tab_art", hash("import_changes"))
	end
	if UI.tab.tab_beat.state and beat_data then
		local beat_tab
		beat_tab, beat_data = G.safe_decode(beat_data)
		if not (beat_tab and G.check_version(beat_data)) then
			G.update_navbar("Enemy/obstacle data not loaded")
		else
			local advanced_types = {Wall = true, TunnelTall = true, TunnelShort = true}
			local advanced_enemies = {FlyingBomb = true, ["Trap Enemy"] = true}
			local obstacle_count, enemy_count = 0, 0
			for key, val in ipairs(beat_tab.beatData) do
				local num_time = tonumber(val.time)
				for k, v in ipairs(val.obstacles) do
					if advanced_types[v.type] then
						for _key, list_val in ipairs(MEM.beat_data.obstacle_list) do
							if tonumber(list_val.time) > num_time then break end
							if list_val.time == val.time and list_val.placement == v.placement then
								list_val.type = v.type
								MEM.beat_data.table[list_val.beat_data_key].obstacles[list_val.obstacles_key].type = v.type
								MEM.beat_data.changed_obstacles[list_val.beat_data_key] = true
								obstacle_count = obstacle_count + 1
								break
							end
						end
					end
				end
				for k, v in ipairs(val.targets) do
					local change_type = advanced_enemies[v.enemyType]
					local change_sequence = advanced_sequences[v.enemySequence]
					if change_type or change_sequence then
						for _key, list_val in ipairs(MEM.beat_data.enemy_list) do
							if tonumber(list_val.time) > num_time then break end
							if list_val.time == val.time and list_val.placement == v.placement and list_val.distance == v.distance and
							list_val.offset == v.enemyOffset then
								if change_sequence then
									list_val.sequence = v.enemySequence
								end
								if change_type then
									list_val.type = v.enemyType
								end
								MEM.beat_data.changed_enemies[_key] = true
								enemy_count = enemy_count + 1
								break
							end
						end
					end
				end
			end
			local str
			if obstacle_count + enemy_count < 1 then
				str = "No changes made"
			else
				str = "Updated "
				if enemy_count > 1 then
					str = str..enemy_count.." enemies."
				elseif enemy_count > 0 then
					str = str.."one enemy"
				end
				if obstacle_count > 0 then
					if enemy_count > 0 then
						str = str.." and "
					end
					if obstacle_count > 1 then
						str = str..obstacle_count.." obstacles"
					else
						str = str.."one obstacle"
					end
				end
			end
			G.update_navbar(str)
		end
	end
end

local function evaluate_button(button)
	if button == "exit" then
		os.exit(1)
	elseif button == "help" then
		sys.open_url("https://mod.io/g/pistol-whip/r/geomancer")
	elseif button == "import_checkbox" then
		SET.import_changes_from_zip = not SET.import_changes_from_zip
		set_checkbox("import_checkbox", SET.import_changes_from_zip)
	elseif button == "export_folder_checkbox" then
		SET.create_folder_on_export = not SET.create_folder_on_export
		set_checkbox("export_folder_checkbox", SET.create_folder_on_export)
	elseif button == "import_level" then
		SET.import_level_changes = not SET.import_level_changes
		set_checkbox("import_level", SET.import_level_changes)
	elseif button == "import_events" then
		SET.import_event_changes = not SET.import_event_changes
		set_checkbox("import_events", SET.import_event_changes)
	elseif button == "import_models" then
		SET.import_model_changes = not SET.import_model_changes
		set_checkbox("import_models", SET.import_model_changes)
	elseif button == "import_beat" then
		SET.import_beat_changes = not SET.import_beat_changes
		set_checkbox("import_beat", SET.import_beat_changes)
	elseif button == "import_changes" then
		import_changes()
	elseif button == "degeomance" then
		degeomance()
	elseif button == "load_file" then
		local num, path = diags.open("pw_meta,pw,pw_beat,pw_event,pw_geo,pw_art,pw_seq", SET.default_path_load_file)
		if path then
			local htap = string.reverse(path)
			local filename = string.reverse(string.sub(htap, 1, string.find(htap, "\\") - 1))
			local extension = string.find(htap, "%.")
			extension = string.reverse(string.sub(htap, 1, extension - 1))
			msg.post("/navbar#navbar", hash("update_status"), {text = "Loading "..filename, clear = true})
			timer.delay(0.02, false, function()
				local panel = MEM.load_file(path, filename, extension)
				if panel then
					msg.post("/navbar#navbar", hash("update_status"), {text = "File loaded successfully"})
					msg.post("/navbar#navbar", hash("update_tabs"))
					check_for_reset()
					update_panel(panel)
				else
					msg.post("/navbar#navbar", hash("update_status"), {text = "File not loaded"})
				end
			end)
		end
	elseif button == "load_zip" then
		local num, path = diags.open("zip", SET.default_path_load_zip)
		if path then
			local f = io.open(path, "rb")
			if f then
				msg.post("/navbar#navbar", hash("update_status"), {text = "Loading files from "..path, clear = true})
				local zip_data = f:read("*a")
				local archive = zip.open(zip_data)
				if not archive then
					msg.post("/navbar#navbar", hash("update_status"), {text = "Error extracting files. Try resaving the map with the current Pistol Mix version or extract the files manually."})
					return
				end
				local file_index = zip.get_number_of_entries(archive) - 1
				local skip_count, extracted_count = 0, 0
				local ext_list = {pw_meta = true, pw = true, pw_beat = true, pw_event = true, pw_geo = true, pw_art = true, pw_seq = true}
				local function extract_next()
					local err, file = pcall(zip.extract_by_index, archive, file_index)
					if not err then
						msg.post("/navbar#navbar", hash("update_status"), {text = "Error extracting files. Try resaving the map with the current Pistol Mix version or extract the files manually."})
						return
					end
					
					local emanelif = string.reverse(file.name)
					local extension_index = string.find(emanelif, "%.")
					if extension_index then
						local extension = string.reverse(string.sub(emanelif, 1, extension_index - 1))
						if ext_list[extension] then
							local panel = MEM.load_file(nil, file.name, extension, file.content) 
							if panel then
								ext_list[extension] = false
								msg.post("/navbar#navbar", hash("update_status"), {text = file.name})
								extracted_count = extracted_count + 1
								update_panel(panel)
							else
								skip_count = skip_count + 1
							end
						else
							skip_count = skip_count + 1
						end
					end
					file_index = file_index - 1
					if file_index < 0 then
						zip.close(archive)
						msg.post("/navbar#navbar", hash("update_status"), {text = "Extracted "..extracted_count.." files, "..skip_count.." skipped."})
						if MEM.level_data.scene_name then
							msg.post("/navbar#navbar", hash("update_status"), {text = "Loaded scene: "..MEM.level_data.scene_name})
							if MEM.level_data.my_map then
								msg.post("/navbar#navbar", hash("update_status"), {text = "Hey, that's one of mine! Hope you like it"})
							end
						else
							msg.post("/navbar#navbar", hash("update_status"), {text = "Unknown scene name"})
						end
						msg.post("/navbar#navbar", hash("update_tabs"))
					else
						timer.delay(0.01, false, extract_next)
					end
				end
				if file_index > -1 then
					timer.delay(0.01, false, extract_next)
				else
					msg.post("/navbar#navbar", hash("update_status"), {text = "Archive is empty."})
				end
				check_for_reset()
			end
		end
	elseif button == "load_dir" then
		local num, path = diags.open_folder(SET.default_path_load_directory)
		if path then
			msg.post("/navbar#navbar", hash("update_status"), {text = "Loading files from "..path, clear = true})
			local files_to_load = {}
			local skip_count = 0
			local ext_list = {pw_meta = true, pw = true, pw_beat = true, pw_event = true, pw_geo = true, pw_art = true, pw_seq = false}
			for filename in lfs.dir(path) do
				if not (filename == "." or filename == "..") then
					local extension = string.find(filename, "%.")
					if extension then
						extension = string.sub(filename, extension + 1)
						if ext_list[extension] then
							table.insert(files_to_load, {path = path.."/"..filename, filename = filename, extension = extension})
							ext_list[extension] = false
						else
							skip_count = skip_count + 1
						end
					end
				end
			end
			if #files_to_load > 0 then
				local function load_next_file()
					local _file = table.remove(files_to_load)
					local panel = MEM.load_file(_file.path, _file.filename, _file.extension)
					if panel then
						msg.post("/navbar#navbar", hash("update_status"), {text = _file.filename})
						msg.post("/navbar#navbar", hash("update_tabs"))
						update_panel(panel)
					else
						msg.post("/navbar#navbar", hash("update_status"), {text = "Error loading ".._file.filename})
					end
					if #files_to_load > 0 then
						timer.delay(0.01, false, load_next_file)
					else
						if MEM.level_data.scene_name then
							msg.post("/navbar#navbar", hash("update_status"), {text = "Done. Loaded scene: "..MEM.level_data.scene_name})
							if MEM.level_data.my_map then
								msg.post("/navbar#navbar", hash("update_status"), {text = "Hey, that's one of mine! Hope you like it"})
							end
						else
							msg.post("/navbar#navbar", hash("update_status"), {text = "Done. Unknown scene name"})
						end
					end
				end
				msg.post("/navbar#navbar", hash("update_status"), {text = "Loading "..#files_to_load.." files, "..skip_count.." skipped."})
				timer.delay(0.01, false, load_next_file)
				check_for_reset()
			else
				msg.post("/navbar#navbar", hash("update_status"), {text = "No valid files found."})
			end
		end
	elseif button == "unload_all" then
		for key, val in pairs(UI.tab) do
			if not (val.state == nil) then
				val.state = false
			end
		end
		UI.tab.tab_file.state = true
		MEM.level_data = {}
		MEM.meta_data = {}
		MEM.beat_data = {}
		MEM.event_data = {}
		MEM.geo_data = {}
		MEM.sequence_data = {}
		MEM.art_data = {}

		msg.post("/event#tab_event", hash("reset"))

		msg.post("/navbar#navbar", hash("update_status"), {text = "All data unloaded.", clear = true})
		msg.post("/navbar#navbar", hash("update_tabs"))
	elseif button == "export_all" then
		export_all(not SET.create_folder_on_export)
	end
end

function on_input(self, action_id, action)
	UI.on_input(TAB_NAME, action_id, action, evaluate_button)
end